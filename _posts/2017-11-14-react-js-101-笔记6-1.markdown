---
layout: post
title:  "react js 101 笔记6-1"
date:   2017-11-14 21:02:31 +0800
categories:  
tags: 
    - react
    - 笔记

---

是对 [ImmutableJS 入门教学](https://github.com/carlleton/reactjs101/blob/zh-CN/Ch06/react-immutable-introduction.md) 的笔记。

* 环境：win7 x64
* 软件：按2次Ctrl 搜索 ： sublime js exe  
[ImmutableJS](https://facebook.github.io/immutable-js/)解决了 `React` 和 `Redux` 的一些问题。

## 实例1 ##

路径：E:\n\learn\react\101\Ch06\demo     
js引用类型： 

```javascript
var map1 = { a: 1 }; 
var map2 = map1; 
map2.a = 2
```
Immutable Data 就是一旦创建，就不能再被更改的数据。
用 Immutable Data 代替深度复制。

```javascript
import Immutable from 'immutable';

var map1 = Immutable.Map({ a: 1, b: 3 });
var map2 = map1.set('a', 2);

map1.get('a'); // 1
map2.get('a'); // 2
```
上面的例子，虽然操作了 `map1` 的值，但原本的 `map1` 未受影响，（例如下面的资料 `b` 即为 `map1` 所 `map2` 共享），有更好的效能表现。 

elifecycle

	ERROR in ./src/index.js
	Module not found: Error: Cannot resolve module 'immutable' in E:\n\learn\react\101\Ch06\demo\src
	 @ ./src/index.js 11:17-37

全局安装，：

	npm install immutable

会自动修改本地的：

  "dependencies": {
    "immutable": "^3.8.2",


本地访问地址 http://localhost:8008  

![6](https://i.imgur.com/fLEDH3K.png)

## ImmutableJS

有7种不变类型：`List`、`Map`、`Stack`、`OrderedMap`、`Set`、`OrderedSet`、`Record`。   
Immutable 物件操作都会回传新值。  
常用 `List`、`Map` 和 `Set`：

1. Map：类似键值对，ES6 有原生 `Map`

  ```javascript
  const Map= Immutable.Map;
  
  // 1. Map 大小
  const map1 = Map({ a: 1 });
  map1.size
  // => 1

  // 2. 新增或取代 Map 元素
  // set(key: K, value: V)
  const map2 = map1.set('a', 7);
  // => Map { "a": 7 }

  // 3. 删除元素
  // delete(key: K)
  const map3 = map1.delete('a');
  // => Map {}

  // 4. 清除 Map 内容
  const map4 = map1.clear();
  // => Map {}

  // 5. 更新 Map 元素
  // update(updater: (value: Map<K, V>) => Map<K, V>)
  // update(key: K, updater: (value: V) => V)
  // update(key: K, notSetValue: V, updater: (value: V) => V)
  const map5 = map1.update('a', () => (7))
  // => Map { "a": 7 }

  // 6. 合并 Map 
  const map6 = Map({ b: 3 });
  map1.merge(map6);
  // => Map { "a": 1, "b": 3 }
  ```

2. List：有序且可以重复值，对应Array

  ```javascript
  const List= Immutable.List;
  
  // 1. 取得 List 长度
  const arr1 = List([1, 2, 3]);
  arr1.size
  // => 3

  // 2. 新增或取代 List 元素内容
  // set(index: number, value: T)
  // 将 index 位置的元素替换
  const arr2 = arr1.set(-1, 7);
  // => [1, 2, 7]
  const arr3 = arr1.set(4, 0);
  // => [1, 2, 3, undefined, 0]

  // 3. 删除 List 元素
  // delete(index: number)
  // 删除 index 位置的元素
  const arr4 = arr1.delete(1);
  // => [1, 3]

  // 4. 插入元素到 List
  // insert(index: number, value: T)
  // 在 index 位置插入 value
  const arr5 = arr1.insert(1, 2);
  // => [1, 2, 2, 3]

  // 5. 清空 List
  // clear()
  const arr6 = arr1.clear();
  // => []
  ```

3. Set：无序且不能重复的列表

  ```javascript
  const Set= Immutable.Set;
  
  // 1. 建立 Set
  const set1 = Set([1, 2, 3]);
  // => Set { 1, 2, 3 }

  // 2. 新增元素
  const set2 = set1.add(1).add(5);
  // => Set { 1, 2, 3, 5 } 
  // 由于 Set 为不能重复集合，故 1 只能出现一次

  // 3. 删除元素
  const set3 = set1.delete(3);
  // => Set { 1, 2 }

  // 4. 取联集
  const set4 = Set([2, 3, 4, 5, 6]);
  set1.union(set4);
  // => Set { 1, 2, 3, 4, 5, 6 }

  // 5. 取交集
  set1.intersect(set4);
  // => Set { 2, 3 }

  // 6. 取差集
  set1.subtract(set4);
  // => Set { 1 }
  ```

## ImmutableJS 的特性整理
1. Persistent Data Structure
  在 `ImmutableJS` 的世界里，只要资料一被创建，就不能修改，维持 `Immutable`。就不会发生下列的状况：

  ```javascript
  var obj = {
   a: 1
  };

  funcationA(obj);
  console.log(obj.a) // 不确定结果为多少？
  ```

  使用 `ImmutableJS` 就没有这个问题：

  ```javascript
  // 有些开发者在使用时会在 ``Immutable` 变数前加 `$` 以示区隔。

  const $obj = fromJS({
   a: 1
  });

  funcationA($obj);
  console.log($obj.get('a')) // 1
  ```

2. Structural Sharing
  为了维持资料的不可变，又要避免像 `deepCopy` 一样复制所有的节点资料而造成的资源损耗，在 `ImmutableJS` 使用的是 Structural Sharing 特性，亦即如果物件树中一个节点发生变化的话，只会修改这个节点和和受它影响的父节点，其他节点则共享。

  ```javascript
  const obj = {
    count: 1,
    list: [1, 2, 3, 4, 5]
  }
  var map1 = Immutable.fromJS(obj);
  var map2 = map1.set('count', 4);

  console.log(map1.list === map2.list); // true
  ```

3. Support Lazy Operation

  ```javascript
  Immutable.Range(1, Infinity)
  .map(n => -n)
  // Error: Cannot perform this action with an infinite size.

  Immutable.Range(1, Infinity)
  .map(n => -n)
  .take(2)
  .reduce((r, n) => r + n, 0); 
  // -3
  ```

4. 丰富的 API 并提供快速转换原生 JavaScript 的方式
  在 ImmutableJS 中可以使用 `fromJS()`、`toJS()` 进行 JavaScript 和 ImmutableJS 之间的转换。但由于在转换之间会非常耗费资源，所以若是你决定引入 `ImmutableJS` 的话请尽量维持资料处在 `Immutable` 的状态。

5. 支持 Functional Programming
  `Immutable` 本身就是 Functional Programming（函数式程式设计）的概念，所以在 `ImmutableJS` 中可以使用许多 Functional Programming 的方法，例如：`map`、`filter`、`groupBy`、`reduce`、`find`、`findIndex` 等。

6. 容易实现 Redo/Undo 历史回顾

## React 效能优化
`ImmutableJS` 除了可以和 `Flux/Redux` 整合外，也可以用于基本 react 效能优化。以下是一般使用效能优化的简单方式：

传统 JavaScript 比较方式，若资料型态为 Primitive 就不会有问题：

```javascript
// 在 shouldComponentUpdate 比较接下来的 props 是否一致，若相同则不重新渲染，提升效能
shouldComponentUpdate (nextProps) {
    return this.props.value !== nextProps.value;
}
```

但当比较的是物件的话就会出现问题：

```javascript
// 假设 this.props.value 为 { foo: 'app' }
// 假设 nextProps.value 为 { foo: 'app' },
// 虽然两者值是一样，但由于 reference 位置不同，所以视为不同。但由于值一样应该要避免重复渲染
this.props.value !== nextProps.value; // true
```

使用 `ImmutableJS`：

```javascript
var SomeRecord = Immutable.Record({ foo: null });
var x = new SomeRecord({ foo: 'app'  });
var y = x.set('foo', 'azz');
x === y; // false
```

在 ES6 中可以使用官方文件上的 `PureRenderMixin` 进行比较，可以让程式码更简洁：

```javascript
import PureRenderMixin from 'react-addons-pure-render-mixin';
class FooComponent extends React.Component {
  constructor(props) {
    super(props);
    this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);
  }
  render() {
    return <div className={this.props.className}>foo</div>;
  }
}
```

## 总结
虽然 `ImmutableJS` 的引入可以带来许多好处和效能的提升但由于引入整体档案较大且较具侵入性，在引入之前可以自行评估看看是否合适于目前的专案。接下来我们将在后面的章节讲解如何将 `ImmutableJS` 和 `Redux` 整合应用到实务上的范例。 

## 延伸阅读
1. [官方网站](https://facebook.github.io/immutable-js/)
2. [Immutable.js初识](http://www.w3cplus.com/javascript/immutable-js.html)
3. [Immutable 详解及 React 中实践](https://github.com/camsong/blog/issues/3)
4. [为什么需要Immutable.js](http://zhenhua-lee.github.io/react/Immutable.html)
5. [facebook immutable.js 意义何在，使用场景？](https://www.zhihu.com/question/28016223)
6. [React 巢状 Component 效能优化](https://blog.wuct.me/react-%E5%B7%A2%E7%8B%80-component-%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96-b01d8a0d3eff#.3kf4h1xq1)
7. [PureRenderMixin](https://facebook.github.io/react/docs/pure-render-mixin.html)
8. [seamless-immutable](https://github.com/rtfeldman/seamless-immutable)
9. [Immutable Data Structures and JavaScript](http://jlongster.com/Using-Immutable-Data-Structures-in-JavaScript)

（image via [risingstack](https://risingstack-blog.s3.amazonaws.com/2016/Jan/immutable_logo_for_react_js_best_practices-1453211749818.png)）

## :door: 任意门
| [回首页](../../../tree/zh-CN/) | [上一章：React Router 入门实战教学](../Ch05/react-router-introduction.md) | [下一章：Flux 基础概念与实战入门](../Ch07/react-flux-introduction.md) |

| [勘误、提问或许愿](https://github.com/kdchang/reactjs101/issues) |



#### 参考 ####

* [reactjs101/react-immutable-introduction.md at zh-CN · carlleton/reactjs101 · GitHub](https://github.com/carlleton/reactjs101/blob/zh-CN/Ch06/react-immutable-introduction.md)
* [React+Redux仿Web追书神器 - jianhuicode - 博客园](http://www.cnblogs.com/lmf-techniques/p/7852525.html)
* [GitHub - bailicangdu/react-pxq: 一个 react + redux 的完整项目 和 个人总结](https://github.com/bailicangdu/react-pxq)
* [React 101: Condensed – Erik Aybar – Medium](https://medium.com/@_erikaybar/one-developers-condensed-intro-to-react-68cbf078f992)
* [jianhui1012/bookreader: 模仿Web追书神器--react+redux](https://github.com/jianhui1012/bookreader)
* [React 101 - React Tutorials for Advanced Beginners](https://ihatetomatoes.net/get-react-101/?utm_source=rw&utm_medium=demo&utm_campaign=collapsible)
* [React Tutorial For Beginners 2017 - YouTube - 正在播放音频](https://www.youtube.com/watch?v=OXmpxz_-pBU&list=PLkEZWD8wbltnXlfyhS5qSMTNb26utkOkI)