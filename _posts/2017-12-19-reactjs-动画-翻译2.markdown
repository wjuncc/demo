---
layout: post
title:  "reactjs 动画 翻译2"
date:   2017-12-19 21:26:49 +0800
categories:  
tags: 
---



### 备忘录 ###
 

这篇文章挺好的，是一整做法，从0开始搭建一个完整的demo。事件也很新，6月25日。  此外，还提供了思路：
如何在reactjs调用非react组件？ 

	import * as Animated from "animated/lib/targets/react-dom";     

有问题的地方是用了一个animatedjs，这个很冷门，也只能用在很少量的动画上。   
中文翻译()
英文()
下面是对他的补充：
[animatedjs](http://animatedjs.github.io/interactive-docs/)

Animated
动画
Animations have for a long time been a weak point of the React ecosystem.
动画长期以来一直是React生态系统的薄弱环节。
The Animated library aims at solving this problem.
动画库旨在解决这个问题。
It embraces the declarative aspect of React and obtains performance by using raw DOM manipulation behind the scenes instead of the usual diff.
它包含React的声明性方面，通过在幕后使用原始DOM操作而不是通常的diff来获得性能。

Animated.Value
Animated.Value
The basic building block of this library is Animated.Value.
这个库的基本构建块是Animated.Value。
This is a variable that's going to drive the animation.
这是一个将驱动动画的变量。
You use it like a normal value in style attribute.
你在style属性中使用它就像一个正常的值。
Only animated components such as Animated.div will understand it.
只有Animated.div等动画组件才能理解它。

React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
};
};
},
}，
return (
返回（
<Animated.div
<Animated.div
style={{left : this.state.animal}}
style = {{left : this.state.animal}}
className="circle"
类名=“圆”
/>
/>
);
）;
},
}，
});
}）;
setValue
设定值
As you can see, the value is being used inside of render() as you would expect.
正如你所看到的那样，这个值正在被render（）所使用。
However, you don't call setState() in order to update the value.
但是，您不要调用setState（）以更新值。
Instead, you can call setValue() directly on the value itself.
相反，您可以直接在值本身上调用setValue（）。
We are using a form of data binding.
我们正在使用一种数据绑定的形式。

The Animated.div component when rendered tracks which animated values it received.
Animated.div组件在渲染轨道时收到动画值。
This way, whenever that value changes, we don't need to re-render the entire component, we can directly update the specific style attribute that changed.
这样，只要该值发生变化，我们就不需要重新渲染整个组件，我们可以直接更新所更改的特定样式属性。

ResetClick
ResetClick
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(0),
anim : new Animated.Value（0），
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<Animated.div
<Animated.div
style={{left : this.state.animal}}
style = {{left : this.state.animal}}
className="circle"
类名=“圆”
onClick={this.handleClick}>
的onClick = {this.handleClick}>
Click
点击
</Animated.div>
</Animated.div>
);
）;
},
}，
handleClick :  function() {
handleClick : function（）{
this.state.anim.setValue(400);
this.state.anim.setValue（400）;
},
}，
});
}）;
Animated.timing
Animated.timing
Now that we understand how the system works, let's play with some animations!
现在我们了解了系统的工作原理，让我们玩一些动画！
The hello world of animations is to move the element somewhere else.
动画的hello世界是将元素移动到其他地方。
To do that, we're going to animate the value from the current value 0 to the value 400.
要做到这一点，我们将动画从当前值0到值400的值。

On every frame (via requestAnimationFrame), the timing animation is going to figure out the new value based on the current time, update the animated value which in turn is going to update the corresponding DOM node.
在每一帧（通过requestAnimationFrame），定时动画将根据当前时间计算新值，更新动画值，然后更新相应的DOM节点。

ResetClick
ResetClick
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(0),
anim : new Animated.Value（0），
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<Animated.div
<Animated.div
style={{left : this.state.animal}}
style = {{left : this.state.animal}}
className="circle"
类名=“圆”
onClick={this.handleClick}>
的onClick = {this.handleClick}>
Click
点击
</Animated.div>
</Animated.div>
);
）;
},
}，
handleClick :  function() {
handleClick : function（）{
Animated.timing(this.state.anim, {toValue :  400}).start();
Animated.timing（this.state.anim，{toValue : 400}）。start（）;
},
}，
});
}）;
Interrupt Animations
中断动画
As a developer, the mental model is that most animations are fire and forget.
作为一名开发者，心智模式是大多数动画是火和忘记。
When the user presses the button, you want it to shrink to 80% and when she releases, you want it to go back to 100%.
当用户按下按钮时，你希望它缩小到80％，当她释放时，你希望它回到100％。

There are multiple challenges to implement this correctly.
正确实施这个有多重的挑战。
You need to stop the current animation, grab the current value and restart an animation from there.
您需要停止当前的动画，抓住当前值并从那里重新开始动画。
As this is pretty tedious to do manually, Animated will do that automatically for you.
由于手动操作非常繁琐，动画会自动为您执行。

ResetPress
ResetPress
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(1),
anim : new Animated.Value（1），
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<Animated.div
<Animated.div
style={{transform : [{scale __ this.state.animal}]}}
style = {{transform : [{scale __ this.state.animal}]}}
className="circle"
类名=“圆”
onMouseDown={this.handleMouseDown}
onmousedown事件= {this.handleMouseDown}
onMouseUp={this.handleMouseUp}>
onMouseUp = {this.handleMouseUp}>
Press
按
</Animated.div>
</Animated.div>
);
）;
},
}，
handleMouseDown :  function() {
handleMouseDown : function（）{
Animated.timing(this.state.anim, { toValue :  0.8 }).start();
Animated.timing（this.state.anim，{toValue : 0.8}）。start（）;
},
}，
handleMouseUp :  function() {
handleMouseUp : function（）{
Animated.timing(this.state.anim, { toValue :  1 }).start();
animated.timing（this.state.anim，{toValue : 1}）。start（）;
},
}，
});
}）;
Animated.spring
Animated.spring
Unfortunately, the timing animation doesn't feel good.
不幸的是，时机动画感觉不好。
The main reason is that no matter how far you are in the animation, it will trigger a new one with always the same duration.
主要原因是，无论你在动画中有多远，都会触发一个持续时间相同的新动画。

The commonly used solution for this problem is to use the equation of a real-world spring.
这个问题的常用解决方案是使用现实世界的春天的方程。
Imagine that you attach a spring to the target value, stretch it to the current value and let it go.
想象一下，您将弹簧附加到目标值，将其拉伸至当前值并释放。
The spring movement is going to be the same as the update.
春季运动将与更新相同。

It turns out that this model is useful in a very wide range of animations.
事实证明，这个模型在非常广泛的动画中是有用的。
I highly recommend you to always start with a spring animation instead of a timing animation.
我强烈建议你总是从春季动画开始，而不是时间动画。
It will make your interface feels much better.
它会让你的界面感觉好多了。

ResetPress
ResetPress
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(1),
anim : new Animated.Value（1），
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<Animated.div
<Animated.div
style={{transform : [{scale __ this.state.animal}]}}
style = {{transform : [{scale __ this.state.animal}]}}
className="circle"
类名=“圆”
onMouseDown={this.handleMouseDown}
onmousedown事件= {this.handleMouseDown}
onMouseUp={this.handleMouseUp}>
onMouseUp = {this.handleMouseUp}>
Press
按
</Animated.div>
</Animated.div>
);
）;
},
}，
handleMouseDown :  function() {
handleMouseDown : function（）{
Animated.spring(this.state.anim, { toValue :  0.8 }).start();
Animated.spring（this.state.anim，{toValue : 0.8}）。start（）;
},
}，
handleMouseUp :  function() {
handleMouseUp : function（）{
Animated.spring(this.state.anim, { toValue :  1 }).start();
Animated.spring（this.state.anim，{toValue : 1}）。start（）;
},
}，
});
}）;
interpolate
插
It is very common to animate multiple attributes during the same animation.
在同一个动画中动画多个属性是非常常见的。
The usual way to implement it is to start a separate animation for each of the attribute.
通常的实现方法是为每个属性启动一个单独的动画。
The downside is that you now have to manage a different state per attribute which is not ideal.
缺点是你现在必须管理不同的状态每个属性是不理想的。

With Animated, you can use a single state variable and render it in multiple attributes.
通过动画，您可以使用单个状态变量并将其呈现为多个属性。
When the value is updated, all the places will reflect the change.
当价值更新时，所有的地方都会反映这个变化。

In the following example, we're going to model the animation with a variable where 1 means fully visible and 0 means fully hidden.
在下面的例子中，我们将用一个变量对动画进行建模，其中1表示完全可见，0表示完全隐藏。
We can pass it directly to the scale attribute as the ranges match.
当范围匹配时，我们可以直接将它传递给scale属性。
But for the rotation, we need to convert [0 ;
但是对于旋转，我们需要将[0; 
1] range to [260deg ;
1]范围到[260deg; 
0deg].
0deg。
This is where interpolate() comes handy.
这是interpolate（）方便的地方。

ResetClick
ResetClick
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(1),
anim : new Animated.Value（1），
};
};
},
}，
componentWillMount :  function() {
componentWillMount : function（）{
this.interpolate = this.state.anim.interpolate({
this.interpolate = this.state.anim.interpolate（{
inputRange :  [0, 1],
inputRange : [0，1]，
outputRange :  ['260deg', '0deg']
outputRange : ['260deg'，'0deg']
});
}）;
this.interpolate.addListener(v => console.log(v));
this.interpolate.addListener（v => console.log（v））;
},
}，
render :  function() {
render : function（）{
return (
返回（
<Animated.div
<Animated.div
style={{
风格= {{
transform : [
转变 :  [
{rotate :  this.interpolate},
{rotate : this.interpolate}，
{scale : this.state.animal},
{scale : this.state.animal}，
]
]
}}
}}
className="circle"
类名=“圆”
onClick={this.handleClick}>
的onClick = {this.handleClick}>
Click
点击
</Animated.div>
</Animated.div>
);
）;
},
}，
handleClick :  function() {
handleClick : function（）{
Animated.spring(this.state.anim, {toValue :  0}).start();
Animated.spring（this.state.anim，{toValue : 0}）。start（）;
}
}
});
}）;
stopAnimation
stopAnimation
The reason why we can get away with not calling render() and instead modify the DOM directly on updates is because the animated values are opaque.
之所以我们可以避免不调用render（），而是直接在更新上修改DOM，是因为动画值是不透明的。
In render, you cannot know the current value, which prevents you from being able to modify the structure of the DOM.
在渲染中，您无法知道当前的值，从而无法修改DOM的结构。

Animated can offload the animation to a different thread (CoreAnimation, CSS transitions, main thread...) and we don't have a good way to know the real value.
动画可以将动画卸载到不同的线程（CoreAnimation，CSS转换，主线程...），我们没有一个很好的方法来知道真正的价值。
If you try to query the value then modify it, you are going to be out of sync and the result will look terrible.
如果您尝试查询该值然后进行修改，那么您将不同步，并且结果看起来很糟糕。

There's however one exception :  when you want to stop the current animation.
但是当你想停止当前的动画时，有一个例外:。
You need to know where it stopped in order to continue from there.
你需要知道它停在哪里以便从那里继续。
We cannot know the value synchronously so we give it via a callback in stopAnimation.
我们不能同步知道这个值，所以我们通过stopAnimation中的回调来给它赋值。
It will not suffer from beign out of sync since the animation is no longer running.
由于动画不再运行，它不会受到不同步的影响。

Reset
重启
<>
<>
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(0)
anim : new Animated.Value（0）
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<div>
<DIV>
<button onClick={() => this.handleClick(-1)}> & lt;</button>
<button onClick = {（）=> this.handleClick（-1）}> & lt; </ button>
<Animated.div
<Animated.div
style={{
风格= {{
transform : [
转变 :  [
{rotate :  this.state.anim.interpolate({
{rotate : this.state.anim.interpolate（{
inputRange :  [0, 4],
inputRange : [0，4]，
outputRange :  ['0deg', '360deg']
outputRange : ['0deg'，'360deg']
})},
}）}，
],
]
position :  'relative'
位置:“相对”
}}
}}
className="circle"
类名=“圆”
/>
/>
</div>
</ DIV>
);
）;
},
}，
handleClick :  function(delta) {
handleClick :函数（delta）{
this.state.anim.stopAnimation(value => {
this.state.anim.stopAnimation（value => {
Animated.spring(this.state.animal, {
Animated.spring（this.state.animal，{
}).start();
}）。开始（）;
});
}）;
},
}，
});
}）;
Gesture-based Animations
基于手势的动画
Most animations libraries only deal with time-based animations.
大多数动画库只处理基于时间的动画。
But, as we move to mobile, a lot of animations are also gesture driven.
但是，随着我们转向移动，许多动画也是手势驱动的。
Even more problematic, they often switch between both modes :  once the gesture is over, you start a time-based animation using the same interpolations.
更有问题的是，一旦手势结束，他们通常在两种模式之间切换，您使用相同的插值来开始基于时间的动画。

Animated has been designed with this use case in mind.
已经设计了这个用例的动画。
The key aspect is that there are three distinct and separate concepts :  inputs, value, output.
关键的一点是有三个截然不同的概念_...投入，价值，产出。
The same value can be updated either from a time-based animation or a gesture-based one.
相同的值可以从基于时间的动画或基于手势的动画更新。
Because we use this intermediate representation for the animation, we can keep the same rendering as output.
因为我们使用这个中间表示的动画，我们可以保持与输出相同的渲染。

HorizontalPan
Horizo​​ntalPan
The code needed to drag elements around is very messy with the DOM APIs.
拖动元素所需的代码与DOM API非常混乱。
On mousedown, you need to register a mousemove listener on window otherwise you may drop touches if you move too fast.
在mousedown上，您需要在窗口上注册一个mousemove监听器，否则如果移动速度太快，您可能会触摸它。 
removeEventListener takes the same arguments as addEventListener instead of an id like clearTimeout.
removeEventListener采用与addEventListener相同的参数，而不是像clearTimeout这样的id。
It's also really easy to forget to remove a listener and have a leak.
忘记删除监听者并泄漏也很容易。
And finally, you need to store the current position and value at the beginning and update only compared to it.
最后，您需要将开始时的当前位置和值存储起来，并仅将其更新。

We introduce a little helper called HorizontalPan which handles all this annoying code for us.
我们介绍一个名为Horizo​​ntalPan的小帮手，它为我们处理所有这些烦人的代码。
It takes an Animated.Value as first argument and returns the event handlers required for it to work.
它将Animated.Value作为第一个参数，并返回它所需的事件处理程序。
We just have to bind this value to the left attribute and we're good to go.
我们只需要把这个值绑定到左边的属性上，我们就可以走了。

ResetDrag
ResetDrag
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(0),
anim : new Animated.Value（0），
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<Animated.div
<Animated.div
style={{left : this.state.animal}}
style = {{left : this.state.animal}}
className="circle"
类名=“圆”
{...Horizontal Pan(this.state.animal)}>
{...水平平移（this.state.animal）}>
Drag
拖动
</Animated.div>
</Animated.div>
);
）;
},
}，
});
}）;
Animated.decay
Animated.decay
One of the big breakthrough of the iPhone is the fact that when you release the finger while scrolling, it will not abruptly stop but instead keep going for some time.
iPhone的重大突破之一就是当你在滚动的时候松开手指，它不会突然停下来，而是继续前进一段时间。

In order to implement this effect, we are using a second real-world simulation :  an object moving on an icy surface.
为了实现这个效果，我们使用了第二个真实世界的模拟_...一个在冰面上移动的对象。
All it needs is two values :  the current velocity and a deceleration coefficient.
所有它需要的是两个值:当前速度和一个减速系数。
It is implemented by Animated.decay.
它由Animated.decay实现。

ResetThrow
ResetThrow
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(0),
anim : new Animated.Value（0），
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<Animated.div
<Animated.div
style={{left : this.state.animal}}
style = {{left : this.state.animal}}
className="circle"
类名=“圆”
{...Horizontal Pan(this.state.animal, {
{...水平平移（this.state.animal，{
onEnd :  this.handleEnd
onEnd _... this.handleEnd
})}>
}）}>
Throw
扔
</Animated.div>
</Animated.div>
);
）;
},
}，
handleEnd :  function({velocity}) {
handleEnd : function（{velocity}）{
Animated.decay(this.state.anim, {velocity}).start();
Animated.decay（this.state.anim，{velocity}）。start（）;
}
}
});
}）;
Animation Chaining
动画链接
The target for an animation is usually a number but sometimes it is convenient to use another value as a target.
动画的目标通常是一个数字，但有时使用另一个值作为目标是很方便的。
This way, the first value will track the second.
这样，第一个值将跟踪第二个。
Using a spring animation, we can get a nice trailing effect.
使用弹簧动画，我们可以得到一个不错的尾随效果。

Reset
重启
Drag
拖动
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
var anims = [0, 1, 2, 3, 4].map((_, i) => new Animated.Value(0));
var anims = [0，1，2，3，4] .map（（_，i）=> new Animated.Value（0））;
Animated.spring(anims[0], {toValue :  anims[1]}).start();
Animated.spring（anims [0]，{toValue : anims [1]}）。start（）;
Animated.spring(anims[1], {toValue :  anims[2]}).start();
Animated.spring（anims [1]，{toValue : anims [2]}）。start（）;
Animated.spring(anims[2], {toValue :  anims[3]}).start();
Animated.spring（anims [2]，{toValue : anims [3]}）。start（）;
Animated.spring(anims[3], {toValue :  anims[4]}).start();
Animated.spring（anims [3]，{toValue : anims [4]}）。start（）;
return {
返回{
anime : anime,
动漫:动漫，
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<div>
<DIV>
{this.state.anims.map((anim, i) =>
{this.state.anims.map（（anim，i）=>
<Animated.div
<Animated.div
style={{left :  anim}}
style = {{left : anim}}
className="circle"
类名=“圆”
{...(i === 4 & & Horizontal Pan(anime, {
{...（i === 4 & & Horizo​​ntal Pan（anime，{
onEnd :  this.handleEnd
onEnd _... this.handleEnd
}))}>
}））}>
{i === 4  &  &  'Drag'}
{i === 4 & &'Drag'}
</Animated.div>
</Animated.div>
)}
）}
</div>
</ DIV>
);
）;
},
}，
handleEnd :  function({velocity}) {
handleEnd : function（{velocity}）{
Animated.decay(this.state.anims[4], {velocity}).start();
Animated.decay（this.state.anims [4]，{velocity}）。start（）;
}
}
});
}）;
addListener
的addListener
As I said earlier, if you track a spring
正如我刚才所说，如果你跟踪一个春天

Reset
重启
Drag
拖动
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
var anims = [0, 1, 2, 3, 4].map((_, i) => new Animated.Value(i * 100));
var anims = [0，1，2，3，4] .map（（_，i）=> new Animated.Value（i * 100））;
anims[0].addListener(this.handleChange);
anims [0] .addListener（this.handleChange）;
return {
返回{
selected :  null,
选中: null，
anime : anime,
动漫:动漫，
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<div>
<DIV>
{this.state.anims.map((anim, i) =>
{this.state.anims.map（（anim，i）=>
<Animated.div
<Animated.div
style={{
风格= {{
left :  anim,
左: anim，
opacity :  i === 0  |  |  i === this.state.selected ?
opacity : i === 0 | | i === this.state.selected？ 
1  :  0.5
1 : 0.5
}}
}}
className="circle"
类名=“圆”
{...(i === 0  &  &  HorizontalPan(anim, { onEnd :  this.handleEnd }))}>
{...（i === 0 & &Horizo​​ntalPan（anim，{onEnd : this.handleEnd}））}>
{i === 0  &  &  'Drag'}
{i === 0 & &'Drag'}
{i === this.state.selected  &  &  'Selected!'}
{i === this.state.selected & &'Selected！'}
</Animated.div>
</Animated.div>
)}
）}
</div>
</ DIV>
);
）;
},
}，
handleChange :  function({value}) {
handleChange :函数（{value}）{
var selected = null;
var selected = null;
this.state.anims.forEach((_, i) => {
this.state.anims.forEach（（_，i）=> {
selected = i;
选择=我;
}
}
});
}）;
if (selected !== this.state.selected) {
if（selected！== this.state.selected）{
this.select(selected)
this.select（选择）的
}
}
},
}，
select(selected) {
选择（选择）{
this.setState({selected}, () => {
this.setState（{selected}，（）=> {
this.state.anims.forEach((anim, i) => {
this.state.anims.forEach（（anim，i）=> {
if (i === 0) { return;
if（i === 0）{return; 
}
}
if (selected === i) {
如果（选择===我）{
Animated.spring(anim, {toValue :  this.state.anims[0]}).start();
Animated.spring（anim，{toValue : this.state.anims [0]}）。start（）;
} else {
} else {
Animated.spring(anim, {toValue :  i * 100}).start();
Animated.spring（anim，{toValue : i * 100}）。start（）;
}
}
});
}）;
});
}）;
},
}，
handleEnd() {
handleEnd（）{
this.select(null);
this.select（NULL）;
Animated.spring(this.state.anims[0], {toValue :  0}).start();
Animated.spring（this.state.anims [0]，{toValue : 0}）。start（）;
}
}
});
}）;
Animated.sequence
Animated.sequence
It is very common to animate
动画是非常普遍的

Reset
重启
Click
点击
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anims :  [0, 1, 2, 3, 4].map((_, i) => new Animated.Value(0.2)),
anims : [0，1，2，3，4] .map（（_，i）=> new Animated.Value（0.2）），
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<div>
<DIV>
{this.state.anims.map((anim, i) =>
{this.state.anims.map（（anim，i）=>
<Animated.div
<Animated.div
style={{opacity :  anim, position :  'relative'}}
style = {{opacity : anim，position :'relative'}}
className="circle"
类名=“圆”
onClick={i === 0  &  &  this.handleClick}>
onClick = {i === 0 & & this.handleClick}>
{i === 0  &  &  'Click'}
{i === 0 & &'Click'}
</Animated.div>
</Animated.div>
)}
）}
</div>
</ DIV>
);
）;
},
}，
handleClick :  function() {
handleClick : function（）{
this.state.anims.forEach(anim => { anim.setValue(0.2); });
this.state.anims.forEach（anim => {anim.setValue（0.2）;}）;
Animated.sequence(
Animated.sequence（
this.state.anims.map(anim => Animated.spring(anim, { toValue :  1 }))
this.state.anims.map（anim => Animated.spring（anim，{toValue : 1}））
).start();
）。开始（）;
},
}，
});
}）;
Reset
重启
Click
点击
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anims :  [0, 1, 2, 3, 4].map((_, i) => new Animated.Value(0.2)),
anims : [0，1，2，3，4] .map（（_，i）=> new Animated.Value（0.2）），
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<div>
<DIV>
{this.state.anims.map((anim, i) =>
{this.state.anims.map（（anim，i）=>
<Animated.div
<Animated.div
style={{opacity :  anim, position :  'relative'}}
style = {{opacity : anim，position :'relative'}}
className="circle"
类名=“圆”
onClick={i === 0  &  &  this.handleClick}>
onClick = {i === 0 & & this.handleClick}>
{i === 0  &  &  'Click'}
{i === 0 & &'Click'}
</Animated.div>
</Animated.div>
)}
）}
</div>
</ DIV>
);
）;
},
}，
handleClick :  function() {
handleClick : function（）{
this.state.anims.forEach(anim => { anim.setValue(0.2); });
this.state.anims.forEach（anim => {anim.setValue（0.2）;}）;
Animated.stagger(
Animated.stagger（
100,
100，
this.state.anims.map(anim => Animated.spring(anim, { toValue :  1 }))
this.state.anims.map（anim => Animated.spring（anim，{toValue : 1}））
).start();
）。开始（）;
},
}，
});
}）;
Reset
重启
Click
点击
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anims :  [0, 1, 2, 3, 4].map((_, i) => new Animated.Value(0.2)),
anims : [0，1，2，3，4] .map（（_，i）=> new Animated.Value（0.2）），
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<div>
<DIV>
{this.state.anims.map((anim, i) =>
{this.state.anims.map（（anim，i）=>
<Animated.div
<Animated.div
style={{opacity :  anim, position :  'relative'}}
style = {{opacity : anim，position :'relative'}}
className="circle"
类名=“圆”
onClick={i === 0  &  &  this.handleClick}>
onClick = {i === 0 & & this.handleClick}>
{i === 0  &  &  'Click'}
{i === 0 & &'Click'}
</Animated.div>
</Animated.div>
)}
）}
</div>
</ DIV>
);
）;
},
}，
handleClick :  function() {
handleClick : function（）{
this.state.anims.forEach(anim => { anim.setValue(0.2); });
this.state.anims.forEach（anim => {anim.setValue（0.2）;}）;
Animated.sequence([
Animated.sequence（[
Animated.parallel(
Animated.parallel（
this.state.anims.map(anim => Animated.spring(anim, { toValue :  1 }))
this.state.anims.map（anim => Animated.spring（anim，{toValue _.. 1）））
),
）
Animated.stagger(
Animated.stagger（
100,
100，
this.state.anims.map(anim => Animated.spring(anim, { toValue :  0.2 }))
this.state.anims.map（anim => Animated.spring（anim，{toValue : 0.2}））
),
）
]).start();
]）。开始（）;
},
}，
});
}）;
ResetClick
ResetClick
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(0),
anim : new Animated.Value（0），
};
};
},
}，
handleClick :  function() {
handleClick : function（）{
var rec = () => {
var rec =（）=> {
Animated.sequence([
Animated.sequence（[
Animated.timing(this.state.anim, {toValue :  -1, duration :  150}),
Animated.timing（this.state.anim，{toValue : -1，duration : 150}），
Animated.timing(this.state.anim, {toValue :  1, duration :  150}),
Animated.timing（this.state.anim，{toValue : 1，duration : 150}），
]).start(rec);
。]）开始（REC）;
};
};
rec();
REC（）;
},
}，
render :  function() {
render : function（）{
return (
返回（
<Animated.div
<Animated.div
style={{
风格= {{
left :  this.state.anim.interpolate({
left : this.state.anim.interpolate（{
inputRange :  [-1, -0.5, 0.5, 1],
inputRange : [-1，-0.5，0.5，1]，
outputRange :  [0, 5, 0, 5]
outputRange : [0，5，0，5]
}),
}），
transform : [
转变 :  [
{rotate :  this.state.anim.interpolate({
{rotate : this.state.anim.interpolate（{
inputRange :  [-1, 1],
inputRange : [-1,1]，
outputRange :  ['-10deg', '10deg']
outputRange : ['-10deg'，'10deg']
})}
}）}
]
]
}}
}}
className="circle"
类名=“圆”
onClick={this.handleClick}>
的onClick = {this.handleClick}>
Click
点击
</Animated.div>
</Animated.div>
);
）;
},
}，
});
}）;
Reset
重启
H-Scroll
H-滚动
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(0)
anim : new Animated.Value（0）
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<div
<DIV
style={{overflow :  'scroll', height :  60}}
style = {{overflow :'scroll'，height : 60}}
onScroll={Animated.event([
onScroll = {Animated.event（[
{target :  {scrollLeft :  this.state.anim}}
{target : {scrollLeft : this.state.anim}}
])}>
]）}>
<div style={{width :  1000, height :  1}} />
<div style = {{width : 1000，height : 1}} />
{[0, 1, 2, 3, 4].map(i =>
{[0，1，2，3，4] .map（i =>
<Animated.div
<Animated.div
style={{
风格= {{
left :  this.state.anim.interpolate({
left : this.state.anim.interpolate（{
inputRange :  [0, 1],
inputRange : [0，1]，
}),
}），
pointerEvents :  'none',
pointerEvents :'none'，
}}
}}
className="circle">
类名=“圆”>
{i === 4  &  &  'H-Scroll'}
{i === 4 & &'H-Scroll'}
</Animated.div>
</Animated.div>
)}
）}
</div>
</ DIV>
);
）;
},
}，
});
}）;
	
