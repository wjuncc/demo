---
layout: post
title:  "reactjs 动画 翻译2"
date:   2017-12-19 21:26:49 +0800
categories:  
tags: 
---



### 备忘录 ###
 

这篇文章挺好的，是一整做法，从0开始搭建一个完整的demo。事件也很新，6月25日。  此外，还提供了思路：
如何在reactjs调用非react组件？ 

	import * as Animated from "animated/lib/targets/react-dom";     

有问题的地方是用了一个animatedjs，这个很冷门，也只能用在很少量的动画上。   
中文翻译()
英文()
下面是对他的补充：
[animatedjs英文](http://animatedjs.github.io/interactive-docs/)

### Animated ###

动画长一直都是React的弱项。
Animated库就是为了解决这个问题。
Animated包含React声明，在背后使用原始DOM操作而不是通常的diff来获得性能。

### Animated.Value ###
基础是Animated.Value。 
这个变量用来将驱动动画。
在style属性中使用，把它当做一个普通的css属性。
只有animated组件（例如Animated.div等）才能理解它。

	'''
	React.createClass({
	  getInitialState: function() {
	    return {
	      anim: new Animated.Value(100),
	    };
	  },
	  render: function() {
	    return (
	      <Animated.div
	        style={{left: this.state.anim}}
	        className="circle"
	      />
	    );
	  },
	});
	'''

### 设定值 setValue ###
用在render()内。
但是，不必为了更新值，去调用setState() 。 
直接在值本身调用setValue() 。
因为使用了数据绑定的形式。

Animated.div组件在渲染时跟踪接收到的动画值。
这样，一旦值发生变化，就直接更新特定样式属性，而不用重新渲染整个组件。

		
	React.createClass({
	  getInitialState: function() {
	    return {
	      anim: new Animated.Value(0),
	    };
	  },
	  render: function() {
	    return (
	      <Animated.div
	        style={{left: this.state.anim}}
	        className="circle"
	        onClick={this.handleClick}>
	        Click
	      </Animated.div>
	    );
	  },
	  handleClick: function() {
	    this.state.anim.setValue(400);
	  },
	});

### Animated.timing ###

了解了系统的工作原理，现在让我们试一试！
动画的hello world，把元素移到其他地方。
为此，把动画当前值从0变到400。

On every frame (via requestAnimationFrame), the timing animation is going to figure out the new value based on the current time, update the animated value which in turn is going to update the corresponding DOM node.
在每一帧（通过requestAnimationFrame），定时动画将根据当前时间计算新值，更新动画值，然后更新相应的DOM节点。



### 中断动画 ###
作为开发者，模式是动画开火和遗忘。
当用户按下按钮时，按钮缩小到80％，释放按钮时，回到100％。

正确实现有多重的挑战。
You need to stop the current animation, grab the current value and restart an animation from there.
您需要停止当前的动画，抓住当前值并从那里重新开始动画。
As this is pretty tedious to do manually, Animated will do that automatically for you.
由于手动操作非常繁琐，动画会自动为您执行。

	React.createClass({
	  getInitialState: function() {
	    return {
	      anim: new Animated.Value(0),
	    };
	  },
	  render: function() {
	    return (
	      <Animated.div
	        style={{left: this.state.anim}}
	        className="circle"
	        onClick={this.handleClick}>
	        Click
	      </Animated.div>
	    );
	  },
	  handleClick: function() {
	    Animated.timing(this.state.anim, {toValue: 400}).start();
	  },
	});


### Animated.spring ###

不幸的是，动画的时机感觉不好。
主要原因是，无论动画距离有多远，动画的持续时间一样。

这个问题的常用解决方案，是使用现实世界的spring方程。

想象一下，您将弹簧附加到目标值，将其拉伸至当前值并释放。 spring的运动模式与此相同。

It turns out that this model is useful in a very wide range of animations.
事实证明，这个模型在非常广泛的动画中是有用的。
I highly recommend you to always start with a spring animation instead of a timing animation.
我强烈建议你总是从春季动画开始，而不是时间动画。
It will make your interface feels much better.
它会让你的界面感觉好多了。

ResetPress
ResetPress
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(1),
anim : new Animated.Value（1），
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<Animated.div
<Animated.div
style={{transform : [{scale __ this.state.animal}]}}
style = {{transform : [{scale __ this.state.animal}]}}
className="circle"
类名=“圆”
onMouseDown={this.handleMouseDown}
onmousedown事件= {this.handleMouseDown}
onMouseUp={this.handleMouseUp}>
onMouseUp = {this.handleMouseUp}>
Press
按
</Animated.div>
</Animated.div>
);
）;
},
}，
handleMouseDown :  function() {
handleMouseDown : function（）{
Animated.spring(this.state.anim, { toValue :  0.8 }).start();
Animated.spring（this.state.anim，{toValue : 0.8}）。start（）;
},
}，
handleMouseUp :  function() {
handleMouseUp : function（）{
Animated.spring(this.state.anim, { toValue :  1 }).start();
Animated.spring（this.state.anim，{toValue : 1}）。start（）;
},
}，
});
}）;
interpolate
插
It is very common to animate multiple attributes during the same animation.
在同一个动画中动画多个属性是非常常见的。
The usual way to implement it is to start a separate animation for each of the attribute.
通常的实现方法是为每个属性启动一个单独的动画。
The downside is that you now have to manage a different state per attribute which is not ideal.
缺点是你现在必须管理不同的状态每个属性是不理想的。

With Animated, you can use a single state variable and render it in multiple attributes.
通过动画，您可以使用单个状态变量并将其呈现为多个属性。
When the value is updated, all the places will reflect the change.
当价值更新时，所有的地方都会反映这个变化。

In the following example, we're going to model the animation with a variable where 1 means fully visible and 0 means fully hidden.
在下面的例子中，我们将用一个变量对动画进行建模，其中1表示完全可见，0表示完全隐藏。
We can pass it directly to the scale attribute as the ranges match.
当范围匹配时，我们可以直接将它传递给scale属性。
But for the rotation, we need to convert [0 ;
但是对于旋转，我们需要将[0; 
1] range to [260deg ;
1]范围到[260deg; 
0deg].
0deg。
This is where interpolate() comes handy.
这是interpolate（）方便的地方。

ResetClick
ResetClick
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(1),
anim : new Animated.Value（1），
};
};
},
}，
componentWillMount :  function() {
componentWillMount : function（）{
this.interpolate = this.state.anim.interpolate({
this.interpolate = this.state.anim.interpolate（{
inputRange :  [0, 1],
inputRange : [0，1]，
outputRange :  ['260deg', '0deg']
outputRange : ['260deg'，'0deg']
});
}）;
this.interpolate.addListener(v => console.log(v));
this.interpolate.addListener（v => console.log（v））;
},
}，
render :  function() {
render : function（）{
return (
返回（
<Animated.div
<Animated.div
style={{
风格= {{
transform : [
转变 :  [
{rotate :  this.interpolate},
{rotate : this.interpolate}，
{scale : this.state.animal},
{scale : this.state.animal}，
]
]
}}
}}
className="circle"
类名=“圆”
onClick={this.handleClick}>
的onClick = {this.handleClick}>
Click
点击
</Animated.div>
</Animated.div>
);
）;
},
}，
handleClick :  function() {
handleClick : function（）{
Animated.spring(this.state.anim, {toValue :  0}).start();
Animated.spring（this.state.anim，{toValue : 0}）。start（）;
}
}
});
}）;
stopAnimation
stopAnimation
The reason why we can get away with not calling render() and instead modify the DOM directly on updates is because the animated values are opaque.
之所以我们可以避免不调用render（），而是直接在更新上修改DOM，是因为动画值是不透明的。
In render, you cannot know the current value, which prevents you from being able to modify the structure of the DOM.
在渲染中，您无法知道当前的值，从而无法修改DOM的结构。

Animated can offload the animation to a different thread (CoreAnimation, CSS transitions, main thread...) and we don't have a good way to know the real value.
动画可以将动画卸载到不同的线程（CoreAnimation，CSS转换，主线程...），我们没有一个很好的方法来知道真正的价值。
If you try to query the value then modify it, you are going to be out of sync and the result will look terrible.
如果您尝试查询该值然后进行修改，那么您将不同步，并且结果看起来很糟糕。

There's however one exception :  when you want to stop the current animation.
但是当你想停止当前的动画时，有一个例外:。
You need to know where it stopped in order to continue from there.
你需要知道它停在哪里以便从那里继续。
We cannot know the value synchronously so we give it via a callback in stopAnimation.
我们不能同步知道这个值，所以我们通过stopAnimation中的回调来给它赋值。
It will not suffer from beign out of sync since the animation is no longer running.
由于动画不再运行，它不会受到不同步的影响。

Reset
重启
<>
<>
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(0)
anim : new Animated.Value（0）
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<div>
<DIV>
<button onClick={() => this.handleClick(-1)}> & lt;</button>
<button onClick = {（）=> this.handleClick（-1）}> & lt; </ button>
<Animated.div
<Animated.div
style={{
风格= {{
transform : [
转变 :  [
{rotate :  this.state.anim.interpolate({
{rotate : this.state.anim.interpolate（{
inputRange :  [0, 4],
inputRange : [0，4]，
outputRange :  ['0deg', '360deg']
outputRange : ['0deg'，'360deg']
})},
}）}，
],
]
position :  'relative'
位置:“相对”
}}
}}
className="circle"
类名=“圆”
/>
/>
</div>
</ DIV>
);
）;
},
}，
handleClick :  function(delta) {
handleClick :函数（delta）{
this.state.anim.stopAnimation(value => {
this.state.anim.stopAnimation（value => {
Animated.spring(this.state.animal, {
Animated.spring（this.state.animal，{
}).start();
}）。开始（）;
});
}）;
},
}，
});
}）;
Gesture-based Animations
基于手势的动画
Most animations libraries only deal with time-based animations.
大多数动画库只处理基于时间的动画。
But, as we move to mobile, a lot of animations are also gesture driven.
但是，随着我们转向移动，许多动画也是手势驱动的。
Even more problematic, they often switch between both modes :  once the gesture is over, you start a time-based animation using the same interpolations.
更有问题的是，一旦手势结束，他们通常在两种模式之间切换，您使用相同的插值来开始基于时间的动画。

Animated has been designed with this use case in mind.
已经设计了这个用例的动画。
The key aspect is that there are three distinct and separate concepts :  inputs, value, output.
关键的一点是有三个截然不同的概念_...投入，价值，产出。
The same value can be updated either from a time-based animation or a gesture-based one.
相同的值可以从基于时间的动画或基于手势的动画更新。
Because we use this intermediate representation for the animation, we can keep the same rendering as output.
因为我们使用这个中间表示的动画，我们可以保持与输出相同的渲染。

HorizontalPan
Horizo​​ntalPan
The code needed to drag elements around is very messy with the DOM APIs.
拖动元素所需的代码与DOM API非常混乱。
On mousedown, you need to register a mousemove listener on window otherwise you may drop touches if you move too fast.
在mousedown上，您需要在窗口上注册一个mousemove监听器，否则如果移动速度太快，您可能会触摸它。 
removeEventListener takes the same arguments as addEventListener instead of an id like clearTimeout.
removeEventListener采用与addEventListener相同的参数，而不是像clearTimeout这样的id。
It's also really easy to forget to remove a listener and have a leak.
忘记删除监听者并泄漏也很容易。
And finally, you need to store the current position and value at the beginning and update only compared to it.
最后，您需要将开始时的当前位置和值存储起来，并仅将其更新。

We introduce a little helper called HorizontalPan which handles all this annoying code for us.
我们介绍一个名为Horizo​​ntalPan的小帮手，它为我们处理所有这些烦人的代码。
It takes an Animated.Value as first argument and returns the event handlers required for it to work.
它将Animated.Value作为第一个参数，并返回它所需的事件处理程序。
We just have to bind this value to the left attribute and we're good to go.
我们只需要把这个值绑定到左边的属性上，我们就可以走了。

ResetDrag
ResetDrag
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(0),
anim : new Animated.Value（0），
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<Animated.div
<Animated.div
style={{left : this.state.animal}}
style = {{left : this.state.animal}}
className="circle"
类名=“圆”
{...Horizontal Pan(this.state.animal)}>
{...水平平移（this.state.animal）}>
Drag
拖动
</Animated.div>
</Animated.div>
);
）;
},
}，
});
}）;
Animated.decay
Animated.decay
One of the big breakthrough of the iPhone is the fact that when you release the finger while scrolling, it will not abruptly stop but instead keep going for some time.
iPhone的重大突破之一就是当你在滚动的时候松开手指，它不会突然停下来，而是继续前进一段时间。

In order to implement this effect, we are using a second real-world simulation :  an object moving on an icy surface.
为了实现这个效果，我们使用了第二个真实世界的模拟_...一个在冰面上移动的对象。
All it needs is two values :  the current velocity and a deceleration coefficient.
所有它需要的是两个值:当前速度和一个减速系数。
It is implemented by Animated.decay.
它由Animated.decay实现。

ResetThrow
ResetThrow
React.createClass({
React.createClass（{
getInitialState :  function() {
getInitialState : function（）{
return {
返回{
anim :  new Animated.Value(0),
anim : new Animated.Value（0），
};
};
},
}，
render :  function() {
render : function（）{
return (
返回（
<Animated.div
<Animated.div
style={{left : this.state.animal}}
style = {{left : this.state.animal}}
className="circle"
类名=“圆”
{...Horizontal Pan(this.state.animal, {
{...水平平移（this.state.animal，{
onEnd :  this.handleEnd
onEnd _... this.handleEnd
})}>
}）}>
Throw
扔
</Animated.div>
</Animated.div>
);
）;
},
}，
handleEnd :  function({velocity}) {
handleEnd : function（{velocity}）{
Animated.decay(this.state.anim, {velocity}).start();
Animated.decay（this.state.anim，{velocity}）。start（）;
}
}
});
}）;

### 动画链接 Animation Chaining ###

The target for an animation is usually a number but sometimes it is convenient to use another value as a target.
动画的目标通常是一个数字，但有时使用另一个值作为目标是很方便的。
This way, the first value will track the second.
这样，第一个值将跟踪第二个。
Using a spring animation, we can get a nice trailing effect.
使用弹簧动画，我们可以得到一个不错的尾随效果。
	
	React.createClass({
	  getInitialState: function() {
	    var anims = [0, 1, 2, 3, 4].map((_, i) => new Animated.Value(0));
	    Animated.spring(anims[0], {toValue: anims[1]}).start();
	    Animated.spring(anims[1], {toValue: anims[2]}).start();
	    Animated.spring(anims[2], {toValue: anims[3]}).start();
	    Animated.spring(anims[3], {toValue: anims[4]}).start();
	    return {
	      anims: anims,
	    };
	  },
	  render: function() {
	    return (
	      <div>
	        {this.state.anims.map((anim, i) =>
	          <Animated.div
	            style={{left: anim}}
	            className="circle"
	            {...(i === 4 && HorizontalPan(anim, {
	              onEnd: this.handleEnd
	            }))}>
	            {i === 4 && 'Drag'}
	          </Animated.div>
	        )}
	      </div>
	    );
	  },
	  handleEnd: function({velocity}) {
	    Animated.decay(this.state.anims[4], {velocity}).start();
	  }
	});

### addListener ### 

正如前面所讲，如果你跟踪spring
	
	React.createClass({
	  getInitialState: function() {
	    var anims = [0, 1, 2, 3, 4].map((_, i) => new Animated.Value(i * 100));
	    anims[0].addListener(this.handleChange);
	    return {
	      selected: null,
	      anims: anims,
	    };
	  },
	  render: function() {
	    return (
	      <div>
	        {this.state.anims.map((anim, i) =>
	          <Animated.div
	            style={{
	              left: anim,
	              opacity: i === 0 || i === this.state.selected ? 1 : 0.5
	            }}
	            className="circle"
	            {...(i === 0 && HorizontalPan(anim, { onEnd: this.handleEnd }))}>
	            {i === 0 && 'Drag'}
	            {i === this.state.selected && 'Selected!'}
	          </Animated.div>
	        )}
	      </div>
	    );
	  },
	  handleChange: function({value}) {
	    var selected = null;
	    this.state.anims.forEach((_, i) => {
	      if (i !== 0 && i * 100 - 50 < value && value <= i * 100 + 50) {
	        selected = i;
	      }
	    });
	    if (selected !== this.state.selected) {
	      this.select(selected)
	    }
	  },
	  select(selected) {
	    this.setState({selected}, () => {
	      this.state.anims.forEach((anim, i) => {
	        if (i === 0) { return; }
	        if (selected === i) {
	          Animated.spring(anim, {toValue: this.state.anims[0]}).start();
	        } else {
	          Animated.spring(anim, {toValue: i * 100}).start();          
	        }
	      });
	    });
	  },
	  handleEnd() {
	    this.select(null);
	    Animated.spring(this.state.anims[0], {toValue: 0}).start();
	  }
	});

### Animated.sequence ### 
对动画来说，频率很普遍的
