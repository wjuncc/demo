---
layout: post
title:  "reactjs 动画 翻译2"
date:   2017-12-19 21:26:49 +0800
categories:  
tags: 
    - react
    - 翻译

---



### 备忘录 ###
 

这篇文章挺好的，是一整做法，从0开始搭建一个完整的demo。事件也很新，6月25日。  此外，还提供了思路：
如何在reactjs调用非react组件？ 

	import * as Animated from "animated/lib/targets/react-dom";     

有问题的地方是用了一个animatedjs，这个很冷门，也只能用在很少量的动画上。   
[中文翻译](http://animatedjs.github.io/interactive-docs/)
[英文](http://animatedjs.github.io/interactive-docs/)
下面是对他的补充，是类Animated的翻译：
[animatedjs英文](http://animatedjs.github.io/interactive-docs/)

### Animated ###

动画长一直都是React的弱项。
Animated库就是为了解决这个问题。
Animated包含React声明，在背后使用原始DOM操作而不是通常的diff来获得性能。

### Animated.Value ###
基础是Animated.Value。 
这个变量用来将驱动动画。
在style属性中使用，把它当做一个普通的css属性。
只有animated组件（例如Animated.div等）才能理解它。

```javascript
React.createClass({
  getInitialState: function() {
    return {
      anim: new Animated.Value(100),
    };
  },
  render: function() {
    return (
      <Animated.div
        style={{left: this.state.anim}}
        className="circle"
      />
    );
  },
});
```

### 设定值 setValue ###
用在render()内。
但是，不必为了更新值，去调用setState() 。 
直接在值本身调用setValue() 。
因为使用了数据绑定的形式。

Animated.div组件在渲染时跟踪接收到的动画值。
这样，一旦值发生变化，就直接更新特定样式属性，而不用重新渲染整个组件。

```javascript
React.createClass({
  getInitialState: function() {
    return {
      anim: new Animated.Value(0),
    };
  },
  render: function() {
    return (
      <Animated.div
        style={{left: this.state.anim}}
        className="circle"
        onClick={this.handleClick}>
        Click
      </Animated.div>
    );
  },
  handleClick: function() {
    this.state.anim.setValue(400);
  },
});
```
### Animated.timing ###

了解了系统的工作原理，现在让我们试一试！
动画的hello world，把元素移到其他地方。
为此，把动画当前值从0变到400。

On every frame (via requestAnimationFrame), the timing animation is going to figure out the new value based on the current time, update the animated value which in turn is going to update the corresponding DOM node.
在每一帧（通过requestAnimationFrame），定时动画将根据当前时间计算新值，更新动画值，然后更新相应的DOM节点。



### 中断动画 ###
作为开发者，模式是动画开火和遗忘。
当用户按下按钮时，按钮缩小到80％，释放按钮时，回到100％。

正确实现有多重的挑战。
You need to stop the current animation, grab the current value and restart an animation from there.
您需要停止当前的动画，抓住当前值并从那里重新开始动画。
As this is pretty tedious to do manually, Animated will do that automatically for you.
由于手动操作非常繁琐，动画会自动为您执行。
```javascript
	React.createClass({
	  getInitialState: function() {
	    return {
	      anim: new Animated.Value(0),
	    };
	  },
	  render: function() {
	    return (
	      <Animated.div
	        style={{left: this.state.anim}}
	        className="circle"
	        onClick={this.handleClick}>
	        Click
	      </Animated.div>
	    );
	  },
	  handleClick: function() {
	    Animated.timing(this.state.anim, {toValue: 400}).start();
	  },
	});
```

### Animated.spring ###

不幸的是，动画的时机感觉不好。
主要原因是，无论动画距离有多远，动画的持续时间一样。

这个问题的常用解决方案，是使用现实世界的spring方程。

想象一下，您将弹簧附加到目标值，将其拉伸至当前值并释放。 spring的运动模式与此相同。

事实证明，这个模型在大部分动画都管用。
强烈建议你总是从弹性动画开始，而不是时间轴动画。 
它会让你的界面感觉好多了。
```javascript
	React.createClass({
	  getInitialState: function() {
	    return {
	      anim: new Animated.Value(0)
	    };
	  },
	  render: function() {
	    return (
	      <div>
	        <button onClick={() => this.handleClick(-1)}>&lt;</button>
	        <Animated.div
	          style={{
	            transform: [
	              {rotate: this.state.anim.interpolate({
	                inputRange: [0, 4],
	                outputRange: ['0deg', '360deg']
	              })},
	            ],
	            position: 'relative'
	          }}
	          className="circle"
	        />
	        <button onClick={() => this.handleClick(+1)}>&gt;</button>
	      </div>
	    );
	  },
	  handleClick: function(delta) {
	    this.state.anim.stopAnimation(value => {
	      Animated.spring(this.state.anim, {
	        toValue: Math.round(value) + delta
	      }).start();
	    });
	  },
	});
```

### interpolate ### 
在同一个动画中同时改变多个属性，很常见。
一般是给每个属性启动一个单独的动画。
缺点是你现在必须管理不同的状态每个属性，所以说是不理想的。
通过动画，您可以使用单个状态变量并将其改变为多个属性。 
当价值更新时，所有地方都会变化。

In the following example, we're going to model the animation with a variable where 1 means fully visible and 0 means fully hidden.
在下面的例子中，我们将用一个变量对动画进行建模，其中1表示完全可见，0表示完全隐藏。
We can pass it directly to the scale attribute as the ranges match.
当范围匹配时，我们可以直接将它传递给scale属性。
But for the rotation, we need to convert [0 ;
但是对于旋转，我们需要将[0; 
1] range to [260deg ;
1]范围到[260deg; 
0deg].
0deg。
This is where interpolate() comes handy.
这是interpolate（）方便的地方。
```javascript
	React.createClass({
	  getInitialState: function() {
	    return {
	      anim: new Animated.Value(1),
	    };
	  },
	  componentWillMount: function() {
	    this.interpolate = this.state.anim.interpolate({
	      inputRange: [0, 1],
	      outputRange: ['260deg', '0deg']
	    });
	    this.interpolate.addListener(v => console.log(v));
	  },
	  render: function() {
	    return (
	      <Animated.div
	        style={{
	          transform: [
	            {rotate: this.interpolate},
	            {scale: this.state.anim},
	          ]
	        }}
	        className="circle"
	        onClick={this.handleClick}>
	        Click
	      </Animated.div>
	    );
	  },
	  handleClick: function() {
	    Animated.spring(this.state.anim, {toValue: 0}).start();
	  }
	});
```
### stopAnimation ###

The reason why we can get away with not calling render() and instead modify the DOM directly on updates is because the animated values are opaque.
之所以我们可以避免不调用render（），而是直接在更新上修改DOM，是因为动画值是不透明的。
In render, you cannot know the current value, which prevents you from being able to modify the structure of the DOM.
在渲染中，您无法知道当前的值，从而无法修改DOM的结构。

Animated can offload the animation to a different thread (CoreAnimation, CSS transitions, main thread...) and we don't have a good way to know the real value.
动画可以将动画卸载到不同的线程（CoreAnimation，CSS转换，主线程...），我们没有一个很好的方法来知道真正的价值。
If you try to query the value then modify it, you are going to be out of sync and the result will look terrible.
如果您尝试查询该值然后进行修改，那么您将不同步，并且结果看起来很糟糕。

There's however one exception :  when you want to stop the current animation.
但是当你想停止当前的动画时，有一个例外:。
You need to know where it stopped in order to continue from there.
你需要知道它停在哪里以便从那里继续。
We cannot know the value synchronously so we give it via a callback in stopAnimation.
我们不能同步知道这个值，所以我们通过stopAnimation中的回调来给它赋值。
It will not suffer from beign out of sync since the animation is no longer running.
由于动画不再运行，它不会受到不同步的影响。
```javascript
React.createClass({
  getInitialState: function() {
    return {
      anim: new Animated.Value(0)
    };
  },
  render: function() {
    return (
      <div>
        <button onClick={() => this.handleClick(-1)}>&lt;</button>
        <Animated.div
          style={{
            transform: [
              {rotate: this.state.anim.interpolate({
                inputRange: [0, 4],
                outputRange: ['0deg', '360deg']
              })},
            ],
            position: 'relative'
          }}
          className="circle"
        />
        <button onClick={() => this.handleClick(+1)}>&gt;</button>
      </div>
    );
  },
  handleClick: function(delta) {
    this.state.anim.stopAnimation(value => {
      Animated.spring(this.state.anim, {
        toValue: Math.round(value) + delta
      }).start();
    });
  },
});
```

### 基于手势的动画 ###
Most animations libraries only deal with time-based animations.
大多数动画库只处理基于时间的动画。
But, as we move to mobile, a lot of animations are also gesture driven.
但是，随着我们转向移动，许多动画也是手势驱动的。
Even more problematic, they often switch between both modes :  once the gesture is over, you start a time-based animation using the same interpolations.
更有问题的是，一旦手势结束，他们通常在两种模式之间切换，您使用相同的插值来开始基于时间的动画。

Animated has been designed with this use case in mind.
已经设计了这个用例的动画。
The key aspect is that there are three distinct and separate concepts :  inputs, value, output.
关键的一点是有三个截然不同的概念_...投入，价值，产出。
The same value can be updated either from a time-based animation or a gesture-based one.
相同的值可以从基于时间的动画或基于手势的动画更新。
Because we use this intermediate representation for the animation, we can keep the same rendering as output.
因为我们使用这个中间表示的动画，我们可以保持与输出相同的渲染。

#### HorizontalPan ####
The code needed to drag elements around is very messy with the DOM APIs.
拖动元素所需的代码与DOM API非常混乱。
On mousedown, you need to register a mousemove listener on window otherwise you may drop touches if you move too fast.
在mousedown上，您需要在窗口上注册一个mousemove监听器，否则如果移动速度太快，您可能会触摸它。 
removeEventListener takes the same arguments as addEventListener instead of an id like clearTimeout.
removeEventListener采用与addEventListener相同的参数，而不是像clearTimeout这样的id。
It's also really easy to forget to remove a listener and have a leak.
忘记删除监听者并泄漏也很容易。
And finally, you need to store the current position and value at the beginning and update only compared to it.
最后，您需要将开始时的当前位置和值存储起来，并仅将其更新。

We introduce a little helper called HorizontalPan which handles all this annoying code for us.
我们介绍一个名为Horizo​​ntalPan的小帮手，它为我们处理所有这些烦人的代码。
It takes an Animated.Value as first argument and returns the event handlers required for it to work.
它将Animated.Value作为第一个参数，并返回它所需的事件处理程序。
We just have to bind this value to the left attribute and we're good to go.
我们只需要把这个值绑定到左边的属性上，我们就可以走了。

```javascript
React.createClass({
  getInitialState: function() {
    return {
      anim: new Animated.Value(0),
    };
  },
  render: function() {
    return (
      <Animated.div
        style={{left: this.state.anim}}
        className="circle"
        {...HorizontalPan(this.state.anim)}>
        Drag
      </Animated.div>
    );
  },
});
```


### Animated.decay ###

One of the big breakthrough of the iPhone is the fact that when you release the finger while scrolling, it will not abruptly stop but instead keep going for some time.
iPhone的重大突破之一就是当你在滚动的时候松开手指，它不会突然停下来，而是继续前进一段时间。

In order to implement this effect, we are using a second real-world simulation :  an object moving on an icy surface.
为了实现这个效果，我们使用了第二个真实世界的模拟_...一个在冰面上移动的对象。
All it needs is two values :  the current velocity and a deceleration coefficient.
所有它需要的是两个值:当前速度和一个减速系数。
It is implemented by Animated.decay.
它由Animated.decay实现。

```javascript
	React.createClass({
	  getInitialState: function() {
	    return {
	      anim: new Animated.Value(0),
	    };
	  },
	  render: function() {
	    return (
	      <Animated.div
	        style={{left: this.state.anim}}
	        className="circle"
	        {...HorizontalPan(this.state.anim, {
	          onEnd: this.handleEnd
	        })}>
	        Throw
	      </Animated.div>
	    );
	  },
	  handleEnd: function({velocity}) {
	    Animated.decay(this.state.anim, {velocity}).start();
	  }
	});
```

### 动画链接 Animation Chaining ###

动画的目标通常是数字，但有时使用另一个值作为目标很方便。
这样，第一个值将跟踪第二个。 
使用弹簧动画，可以得到一个不错的尾随效果。
	
```javascript
	React.createClass({
	  getInitialState: function() {
	    var anims = [0, 1, 2, 3, 4].map((_, i) => new Animated.Value(0));
	    Animated.spring(anims[0], {toValue: anims[1]}).start();
	    Animated.spring(anims[1], {toValue: anims[2]}).start();
	    Animated.spring(anims[2], {toValue: anims[3]}).start();
	    Animated.spring(anims[3], {toValue: anims[4]}).start();
	    return {
	      anims: anims,
	    };
	  },
	  render: function() {
	    return (
	      <div>
	        {this.state.anims.map((anim, i) =>
	          <Animated.div
	            style={{left: anim}}
	            className="circle"
	            {...(i === 4 && HorizontalPan(anim, {
	              onEnd: this.handleEnd
	            }))}>
	            {i === 4 && 'Drag'}
	          </Animated.div>
	        )}
	      </div>
	    );
	  },
	  handleEnd: function({velocity}) {
	    Animated.decay(this.state.anims[4], {velocity}).start();
	  }
	});
```

### addListener ### 

正如前面所讲，如果你跟踪弹簧动画：
	
```javascript
	React.createClass({
	  getInitialState: function() {
	    var anims = [0, 1, 2, 3, 4].map((_, i) => new Animated.Value(i * 100));
	    anims[0].addListener(this.handleChange);
	    return {
	      selected: null,
	      anims: anims,
	    };
	  },
	  render: function() {
	    return (
	      <div>
	        {this.state.anims.map((anim, i) =>
	          <Animated.div
	            style={{
	              left: anim,
	              opacity: i === 0 || i === this.state.selected ? 1 : 0.5
	            }}
	            className="circle"
	            {...(i === 0 && HorizontalPan(anim, { onEnd: this.handleEnd }))}>
	            {i === 0 && 'Drag'}
	            {i === this.state.selected && 'Selected!'}
	          </Animated.div>
	        )}
	      </div>
	    );
	  },
	  handleChange: function({value}) {
	    var selected = null;
	    this.state.anims.forEach((_, i) => {
	      if (i !== 0 && i * 100 - 50 < value && value <= i * 100 + 50) {
	        selected = i;
	      }
	    });
	    if (selected !== this.state.selected) {
	      this.select(selected)
	    }
	  },
	  select(selected) {
	    this.setState({selected}, () => {
	      this.state.anims.forEach((anim, i) => {
	        if (i === 0) { return; }
	        if (selected === i) {
	          Animated.spring(anim, {toValue: this.state.anims[0]}).start();
	        } else {
	          Animated.spring(anim, {toValue: i * 100}).start();          
	        }
	      });
	    });
	  },
	  handleEnd() {
	    this.select(null);
	    Animated.spring(this.state.anims[0], {toValue: 0}).start();
	  }
	});
```

### Animated.sequence ### 
对动画来说，频率很普遍的

```javascript
aaa
```