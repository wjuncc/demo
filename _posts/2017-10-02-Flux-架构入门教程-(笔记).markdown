---
layout: post
title:  "Flux 架构入门教程 (笔记)"
date:   2017-10-02 15:50:16 +0800
categories:  
tags: 
    - react 

---

source from [Flux 架构入门教程](http://www.ruanyifeng.com/blog/2016/01/flux.html)

先看 [《React入门教程》](http://www.ruanyifeng.com/blog/2015/03/react.html)。  
做网站，至少要会一种组合：

* React+Flux,
* React+redux

本教程是es5，不是es6，
官方 [Flux 框架](https://facebook.github.io/flux/)。

![](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016011501.png)


## 一、Flux 是什么？

跟[MVC 架构](http://www.ruanyifeng.com/blog/2007/11/mvc.html)类似，但是更加[简单和清晰](http://www.infoq.com/news/2014/05/facebook-mvc-flux)。

Flux有[15种实现](https://github.com/voronianski/flux-comparison)，默认[Facebook官方实现](https://github.com/facebook/flux)。

## 二、安装 Demo

[Demo](https://github.com/ruanyf/extremely-simple-flux-demo)。  
powershell
```powershell
cd E:\n\learn\react
mkdir flux\ryf
cd flux\ryf 
git clone https://github.com/ruanyf/extremely-simple-flux-demo.git
cd extremely-simple-flux-demo
npm install
Start-Process chrome.exe http://localhost:8080/
npm start
```

![](https://i.imgur.com/PKikNph.gif)  


## 三、基本概念

Flux 的基本概念。

首先，Flux将一个应用分成四个部分。

> - **View**： 视图层
> - **Action**（动作）：视图层发出的消息（比如mouseClick）
> - **Dispatcher**（派发器）：用来接收Actions、执行回调函数
> - **Store**（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面

![](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016011503.png)

Flux 的最大特点，就是数据的"单向流动"。

> 1. 用户访问 View
> 2. View 发出用户的 Action
> 3. Dispatcher 收到 Action，要求 Store 进行相应的更新
> 4. Store 更新后，发出一个"change"事件
> 5. View 收到"change"事件后，更新页面

## 四、View（第一部分）

[`index.jsx`](https://github.com/ruanyf/extremely-simple-flux-demo/blob/master/index.jsx) ，只加载了一个组件。
```js
var React = require('react');
var ReactDOM = require('react-dom');
var MyButtonController = require('./components/MyButtonController');

ReactDOM.render(
  <MyButtonController/>,
  document.querySelector('#example')
);
```

上面代码中，组件名字不是 `MyButton`，而是 `MyButtonController`。这是 React 的 [controller view](http://blog.andrewray.me/the-reactjs-controller-view-pattern/) 模式。"controller view"组件用来`保存状态`，并转发给子组件。`MyButtonController`代码：

```js
var React = require('react');
var ListStore = require('../stores/ListStore');
var ButtonActions = require('../actions/ButtonActions');
var MyButton = require('./MyButton');

var MyButtonController = React.createClass({
  getInitialState: function () {
    return {
      items: ListStore.getAll()
    };
  },

  componentDidMount: function() {
    ListStore.addChangeListener(this._onChange);
  },

  componentWillUnmount: function() {
    ListStore.removeChangeListener(this._onChange);
  },

  _onChange: function () {
    this.setState({
      items: ListStore.getAll()
    });
  },

  createNewItem: function (event) {
    ButtonActions.addNewItem('new item');
  },

  render: function() {
    return <MyButton
      items={this.state.items}
      onClick={this.createNewItem}
    />;
  }

});

module.exports = MyButtonController;
```

注意有`ButtonActions`, 
上面代码中，`MyButtonController`将参数传给子组件`MyButton`。

components/MyButton.jsx
```js
var React = require('react');

var MyButton = function(props) {
  var items = props.items;
  var itemHtml = items.map(function (listItem, i) {
    return <li key={i}>{listItem}</li>;
  });

  return <div>
    <ul>{itemHtml}</ul>
    <button onClick={props.onClick}>New Item</button>
  </div>;
};

module.exports = MyButton;

```

上面代码中，`MyButton`是一个纯组件（即不含有任何状态），方便复用。是"controll view"优点。

`MyButton`只有一个逻辑，用户点击，就调用`this.createNewItem`方法，向Dispatcher发出一个Action。
components/MyButtonController.jsx 
```js
  createNewItem: function (event) {
    ButtonActions.addNewItem('new item');
  },
```
上面代码中，调用`createNewItem`方法，会触发名为`addNewItem`的Action。

## 五、Action

每个Action都是一个对象，包含一个`actionType`属性（说明动作的类型）和一些其他属性（用来传递数据）。

在这个Demo里面，`ButtonActions` 对象用于存放所有的Action。
```js
var AppDispatcher = require('../dispatcher/AppDispatcher');

var ButtonActions = {

  addNewItem: function (text) {
    AppDispatcher.dispatch({
      actionType: 'ADD_NEW_ITEM',
      text: text
    });
  },

};

module.exports = ButtonActions;

```

上面 `ButtonActions.addNewItem`方法使用`AppDispatcher`，把动作`ADD_NEW_ITEM`派发到Store。

## 六、Dispatcher

Dispatcher 的作用是将 Action 派发到 Store、。看作路由器，负责在 View 和 Store 之间，建立 Action 的正确传递路线。注意，Dispatcher 只能有一个，而且是全局的。

官方的 [Dispatcher 实现](https://github.com/facebook/flux)输出一个类，你要写一个`AppDispatcher.js`，生成 Dispatcher 实例。

```js
// dispatcher/AppDispatcher.js
var Dispatcher =require('flux').Dispatcher;
module.exports =newDispatcher();
```

`AppDispatcher.register()`方法登记Action的回调函数。

AppDispatcher.js:
```js
var Dispatcher = require('flux').Dispatcher;
var AppDispatcher = new Dispatcher();
var ListStore = require('../stores/ListStore');

AppDispatcher.register(function (action) {
  switch(action.actionType) {
    case 'ADD_NEW_ITEM':
      ListStore.addNewItemHandler(action.text);
      ListStore.emitChange();
      break;
    default:
      // no op
  }
})

module.exports = AppDispatcher;

```

上面代码中，Dispatcher收到`ADD_NEW_ITEM`动作，就会执行回调函数，对`ListStore`操作。

Dispatcher 只用来派发 Action，不应该有其他逻辑。

## 七、Store

Store 保存整个应用的状态。像 MVC 的Model 。
`ListStore`，所有数据都存放在那里。
stores/ListStore.js
```js
var EventEmitter = require('events').EventEmitter;
var assign = require('object-assign');

var ListStore = assign({}, EventEmitter.prototype, {
  items: [],

  getAll: function () {
    return this.items;
  },

  addNewItemHandler: function (text) {
    this.items.push(text);
  },

  emitChange: function () {
    this.emit('change');
  },

  addChangeListener: function(callback) {
    this.on('change', callback);
  },

  removeChangeListener: function(callback) {
    this.removeListener('change', callback);
  }
});

module.exports = ListStore;

``` 

上面代码中，`ListStore.items`保存条目，`ListStore.getAll()`读取所有条目，`ListStore.emitChange()`发出一个"change"事件。

由于 Store 需要在变动后向 View 发送"change"事件，因此它必须实现事件接口。
stores/ListStore.js


上面代码中，`ListStore`继承了`EventEmitter.prototype`，因此就能使用`ListStore.on()`和`ListStore.emit()`，来监听和触发事件了。

Store 更新后（`this.addNewItemHandler()`）发出事件（`this.emitChange()`），表明状态已经改变。 View 监听到这个事件，就可以查询新的状态，更新页面了。

## 八、View   （第二部分）

现在，我们再回过头来修改 [View](https://github.com/ruanyf/extremely-simple-flux-demo/blob/master/components/MyButtonController.jsx) ，让它监听 Store 的 `change` 事件。

>     
>     // components/MyButtonController.jsx
>     var React =require('react');var ListStore =require('../stores/ListStore');var ButtonActions =require('../actions/ButtonActions');var MyButton =require('./MyButton');var MyButtonController = React.createClass({
>       getInitialState:function(){return{
>           items: ListStore.getAll()};},
>     
>       componentDidMount:function(){
>         ListStore.addChangeListener(this._onChange);},
>     
>       componentWillUnmount:function(){
>         ListStore.removeChangeListener(this._onChange);},
>     
>       _onChange:function(){
>         this.setState({
>           items: ListStore.getAll()});},
>     
>       createNewItem:function(event){
>         ButtonActions.addNewItem('new item');},
>     
>       render:function(){return<MyButton
>           items={this.state.items}
>           onClick={this.createNewItem}/>;}});

上面代码中，你可以看到当`MyButtonController` 发现 Store 发出 `change` 事件，就会调用 `this._onChange` 更新组件状态，从而触发重新渲染。

>     
>     // components/MyButton.jsx
>     var React =require('react');var MyButton =function(props){var items = props.items;var itemHtml = items.map(function(listItem, i){return<li key={i}>{listItem}</li>;});return<div><ul>{itemHtml}</ul><button onClick={props.onClick}>New Item</button></div>;};
>     
>     module.exports = MyButton;

## 九、致谢

本文受到了Andrew Ray 的文章[《Flux For Stupid People》](http://blog.andrewray.me/flux-for-stupid-people/)的启发。

（完）


## 留言（79条） 
             
看一遍根本不懂   

action不一定要放在controller view里，要是组件层次很深，传props会很累的，可以直接放在需要和action打交道的view里，fb的官方示例(todomcv和chat)就是这么做的    

文章中 MyButtonController.jxs 的示例中的类名误写成 MyButton 了. 
                

第一部分：

var MyButton = React.createClass({

......

});

这里的 MyButton 应该是 MyButtonController 吧？
 

----------------------------------------
### 反对意见：   ###
Flux 的设计理念确实很棒，但是一个简单的列表就可以搞这么复杂，实在是不太利于做项目 

----------------------------------------
我表示非常不认同把Flux与MVC放在一起说，Flux完全是另外一种Pattern。 

使用Angular1.x版本中，未来会接触React，加油！ 

监听 Action 的回调那段写的不对吧？应该写在 Store 里，而不是 AppDispatcher；

比如官方 example 里的这一段https://github.com/facebook/flux/blob/master/examples%2Fflux-todomvc%2Fjs%2Fstores%2FTodoStore.js

而且例子里如果能举一下 waitFor 的用法，更能体现 Flux 的精髓 

贴个一年前翻译的启发文章链接。http://caichao.me/2015-01-14-FluxForStupidPeople.html
   
                 
                

>     引用edokeh的发言：
> 
> 
> 监听 Action 的回调那段写的不对吧？应该写在 Store 里，而不是 AppDispatcher；
> 
> 比如官方 example 里的这一段https://github.com/facebook/flux/blob/master/examples%2Fflux-todomvc%2Fjs%2Fstores%2FTodoStore.js
> 
> 而且例子里如果能举一下 waitFor 的用法，更能体现 Flux 的精髓

同问
AppDispatcher 这段回调为什么不写在store里 
         
@edokeh，@tata：

我觉得，与派发器有关的逻辑，都放在AppDispatch比较好。这样，Store就不用加载AppDispatch了。 


----------------------------------------
阮大大，其实我觉得flux是mvc的更好的实践吧，action类似于controller的角色。

第一：改了名字之后，感觉更加向ui靠拢，意为ui的动作，更加直接的指向了ui输入。另外，这样做的好处也是为每一个ui输入留下一笔记录。

第二：也更加明确了action的范围，只是向model发送事件，不对model做任何直接的改变，model内部通过action发来的事件自己处理数据。这也使得model的改变有了稳定的位置，有利于控制和追踪代码。

----------------------------------------
不知道我这样的理解是否正确？  

Facebook画的那个MVC的图，View和Model之间是直接互相调用的，而且这么多个View和Model才对应一个Controller，似乎跟我对MVC的理解有很大出入。

我分别用Flux和MVC各实现了一次Todo。老实说，没看出Flux的优点，反倒觉得有以下缺点：

1. 规定Dispatcher为全局的单例。个人认为任何全局对象或者单例都会降低对它有依赖的类的内聚性，也会造成对View和Store单元测试上的障碍。比方说，定义一个class A，它内部调用了单例class B。首先A的接口没有体现出这种依赖，单元测试也不方便mock。其次对A的所有测试用例，都要把B的行为考虑进去。

2. View同时依赖于Store和Dispatcher。在MVC中，Model和View的所有事件都通过Controller来中转，保证了View和Model的独立。而Flux中，View触发事件（Action）时是通过Dispatcher间接传到Store上，但取数据时又是直接访问Store。导致View需要同时依赖于Store和Dispatcher，这更像是一种倒退。


 _onChange: function () {

    this.setState({

      items: ListStore.getAll()

    });

  },

这个触发后， this 对象变为了 store 对象。没有setState 方法，老师遇到这个问题没
 

对flux的action dispatch表示费解， 和 PubSub一样吗？

我直接放弃flux，用pubsub来处理。 

最上层的组件（Controller）subscribe事件， 子组件（View）publish触发事件去该表store（Model）。

store变化由最顶层setState， 子组件通过 shouldComponentUpdate(nextProps, nextState) 来决定是否更新。

感觉本质上应该是一样的。  
                

阮老师的这篇讲解Flux技术的文章比之于其它草草翻译官方文档的文章来说的确非常容易理解，深入浅出。仔细看了两三遍后，的确明白了这种架构数据流的过程。但是，其实还有一点不甚清楚的就是为什么要如此来处理数据流，这样有什么好处等等，关于这几点感觉文章并没有提到。因为，单纯从例子来看，反而觉得不用Flux会更简洁、方便一些。 
  

其实我的理解 就是广播机制更细化了而已……

先说说对广播机制的理解----有一个radio center，任何对象都可以订阅它

如radio.on(xxx,function(){ do....})

然后也可以通过它来发消息

Radio.push(xxx)

订阅了该消息的对象，响应的做些行为

而flux就是把on和push的写法抽离到了action和dispatch里统一管理，但这种抽离不见的一定好。
 
 
 之前一直接触的是js和页面，对于安装的指令看不明白，现在都无法启动例子。有没有简单的教程呢？
   

阮老师什么时候讲讲redux和webpack啊？
  

组件化开发之后就明白好处了啊。细流合成江湖，公用状态方便获取等。

二是数据都汇起来了方便做实时监测。
   

 说：
                

感觉确实不如redux思路清晰，只是作为了解皆可以了。
 

讲的很棒，一遍就懂了。 
之前用过vuex，但概念上一直有点模糊，看了阮大神的文章，感觉清晰多了。 
                

在store的数据层为什么addChangeListener里面的this后面跟on而在removeChangeListener里面的this后面不是更on的？
 

请问阮老师MyButton那个组件是怎么回事？为什么是function的？import了React为什么没有用到的？

                

大神我下载了代码，在自己的机器上看，为啥没有这两个js文件（init.js，bundle.js）呢？访问报错了
  

学React没多久，看您这篇文章遇到一个困惑。在您的MyButtonController.jsx中，return了标签，按理说这个MyButton应该是一个组件，但是为什么在Mybutton.jsx中却没有用React.createClass去创建这个组件，而Mybutton却是一个function呢？求解惑...
 

同问，在MyButtonController.jsx引用了这个《MyButton /》这个标签，这个标签按说应该是一个组件，可是在MyButton.jsx却是用function去定义的这个？为什么这样，如果这样定义，他为什么可以通过标签《MyButton /》去引用？ 

然后在webpack.config.js中删除插件openBrowser在启动就可以了呢？
 
 

_onChange那里确实会报this.setState is undefined
  
> 同问，在MyButtonController.jsx引用了这个《MyButton /》这个标签，这个标签按说应该是一个组件，可是在MyButton.jsx却是用function去定义的这个？为什么这样，如果这样定义，他为什么可以通过标签《MyButton /》去引用？

看下创建React组件的方式，有三种方式，大神用的这种叫无状态组件，

createCLass方式是es5的方式，还有一种es6的方式，就是class Mybutton extends React.component{ //xxxx }
  

这个组件 如果多次使用的话  就是一个页面出现多个 不能独立开来  数据都是共享的 
                

请问“Flux 的最大特点，就是数据的"单向流动"。”上面那个流程图是什么工具画的？ 

还是更喜欢redux的思路多一些  不过阮老师的文章确实帮助入门不少 浅显易懂 感谢
 
                 
                

请问，MyButtonController.jsx中的ListStore.addChangeListener(this._onChange)，是如何保证参数_onChange函数中出现的this指向的是MyButtonController组件对象而不是window对象？
 
                

写的很好，我看了两遍才看明白，我的目的不是学flux，而是redux，但学redux之前要学flux，我感到难过的是，demo我运行不了，报错，而且可能阮老师的文章写的早，写法跟现在写法不一样，不过还是理解了flux的流程，比书上讲的明白，thanks  

怎么看Web上的这些工具框架都想是WPF和QML的复杂抄袭版本。 
 
我把Demo下载安装后能运行，但不理解setState函数在哪里定义的？
 

看了四五遍，终于有点眉目了！更新个数据，facebook搞的这么麻烦！不过厉害了我的峰哥，你是我心中的支柱！
 
                

讲的不错，不过例子感觉不够好，感觉例子可以用更简单的办法写出来，感觉这样用让flux大材小用了
 