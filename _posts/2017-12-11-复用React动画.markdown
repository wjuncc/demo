---
layout: post
title:  "复用React动画（译）"
date:   2017-12-11 03:45:26 +0800
categories:  
tags: 
    - react
    - 笔记

---

Mar 14, 2016

**关于标题**  
原名，[Reusing ReactTransitionGroup animations with Higher-order Components](https://medium.com/appifycanada/reusing-reacttransitiongroup-animations-with-higher-order-components-1e7043451f91)  
《使用高阶组件重用ReactTransitionGroup动画》，好拗口。    
《使用HOC重用RTG动画》，太晦涩。  
《复用React动画》。 

## **小结**  ##

* 在线Demo的代码，和教程的代码，不一样。
* 教程用了es7的写法，而现在普遍是es6
* 在github搜索了一下，发现HOC+TweenMax的少之又少，看来实战中，不这么用。  
在github搜索 TweenMax componentWillEnter findDOMNode ,  
能得到很多线索。  
* 高阶组件，HOC，套，是一个东西，很重要。  
HOC有2种写法，`PP`和`II`。本教程用的是`PP`，也就是属性代理。   
但是，本教程的PP，和[`高阶教程`](https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e)的PP，写法完全不同。  
主要卡在render函数，按照[`高阶教程`](https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e)的写法，渲染的时候，添加前置声明，可以将内组件的引用传给HOC的函数。  
但是，生死钩比较特殊，它本身就带一个callback参数，这个时候，是添加新的参数？这不会破坏结构吗？就不知道该怎么写了。   
而且，退一步讲，**即便是把内组件的引用顺利的传给生死钩，传过来的引用也是虚拟DOM，不是原始DOM。** 这有什么用？ 而TweenMax要求操作的是原始DOM。    
所以，下面的写法，还是用本篇叫教程的写法来做的。 

## 笔记 ##
运行结果：  
![3](https://i.imgur.com/tuKRKyu.gif) 

文件： E:\n\learn\react\101\Ch04\proj3  

运行： 
	
	cd E:\n\learn\react\101\Ch04\proj3
	npm start

index.html

```html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="src/TweenMax.js"></script>
    <style>
        .box{
            width:200px;
            height:200px;
            background-color: brown;
        }
        .circle { 
            width:200px;
            height:200px;
            background-color: darkorange;
            border-radius: 100%;
        }
    </style>
</head>
<body>
    <div id="container"></div>
</body>
</html>
```


index.js
```javascript
import React from 'react';
import {findDOMNode} from 'react-dom';
import { render } from 'react-dom';
import TransitionGroup from 'react-addons-transition-group';


function makeFadesUp(Component, options = { duration: 0.3 }) {
  return class FadesUp extends React.Component {
    componentWillEnter (callback) {
        const el = findDOMNode(this);
        TweenMax.fromTo(el, options.duration, {y: 100, opacity: 0}, {y: 0, opacity: 1, onComplete: callback});
    }
    componentWillLeave (callback) {
        const el = findDOMNode(this);
        TweenMax.fromTo(el, options.duration, {y: 0, opacity: 1}, {y: -100, opacity: 0, onComplete: callback});
    }
    render () {
        return <Component ref="child" {...this.props} />;
    }
  }
}

function fadesUp (Component) {
  return typeof arguments[0] === "function"
    ? makeFadesUp(arguments[0])
    : Component => makeFadesUp(Component, arguments[0]);
}

const Box = fadesUp({duration: 0.8})(
    class extends React.Component {
    render () {
        return <div className="box"/>;
    }
});

const Circle = fadesUp(
    class extends React.Component {
    render () {
        return <div className="circle"/>;
    }
});

class Page extends React.Component {
    constructor() {
        super();
        this.toggleBox = this.toggleBox.bind(this);
		this.state = {
			shouldShowBox: true,
            shouldShowCircle: false
		};
    };

    toggleBox(){
        this.setState({
            shouldShowBox: !this.state.shouldShowBox,
            shouldShowCircle: !this.state.shouldShowCircle
        });
    };

    render () {
        return <div className="page">
            <TransitionGroup>
                { this.state.shouldShowBox && <Box/>}
                { this.state.shouldShowCircle && <Circle/>}
            </TransitionGroup>

			<button
				className="toggle-btn"
				onClick={this.toggleBox}
			>
				toggle
			</button>
		</div>;
    }
}

render(<Page/>, document.querySelector('#container'));
```
 


## 原文 ##
**前情回顾**  
上一讲，以一个正方形为例，讲了动画的写法。

上一讲讲过，为了让过渡组内的组件更灵活——不同阶段运行不同动画，不在过渡组定义动画，而是在过渡组的子组件定义动画，具体是指：添加生死钩-进入（enter），删除生死钩-离开（leave）。


但是，有的时候，多个组件要使用相同动画，又不希望下作的复制代码。   
可以通过使用高阶组件（Higher-order Components ——HOC）来实现。 
（如果不熟悉HOC，看[这里](http://efe.baidu.com/blog/mixins-are-dead-long-live-the-composition/)，[英语原文](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750)）


### 提取动画 ###

接着上一讲的Box组件实例继续。

```javascript
class Box extends React.Component {
  componentWillEnter (callback) {
    const el = findDOMNode(this);
    TweenMax.fromTo(el, 0.3, {y: 100, opacity: 0}, {y: 0, opacity: 1, onComplete: callback});
  }

  componentWillLeave (callback) {
    const el = findDOMNode(this);
    TweenMax.fromTo(el, 0.3, {y: 0, opacity: 1}, {y: -100, opacity: 0, onComplete: callback});
  }

  render () {
    return <div className="box"/>;
  }
}
```

可以将动画部分提取到名为“`fadesUp`”的高阶组件。

```javascript
function fadesUp (Component) {
  return class FadesUp extends React.Component {
    componentWillEnter (callback) {
      const el = findDOMNode(this);
      TweenMax.fromTo(el, 0.3, {y: 100, opacity: 0}, {y: 0, opacity: 1, onComplete: callback});
    }

    componentWillLeave (callback) {
      const el = findDOMNode(this);
      TweenMax.fromTo(el, 0.3, {y: 0, opacity: 1}, {y: -100, opacity: 0, onComplete: callback});
    }

    render () {
      return <Component ref="child" {...this.props} />;
    }
  }
}
```


想让组件运行动画？ 只要把组件传递给`fadesUp`，就行了。 

下面是正方形

```javascript
const Box = fadesUp(class extends React.Component {
  render () {
    return <div className="box"/>;
  }
});
```

或者，如果启用了装饰器（参考[通过Babel 6使用ES7装饰器](http://technologyadvice.github.io/es7-decorators-babel6/)）

```javascript
@fadesUp
class Box extends React.Component {
  render () {
    return <div className="box"/>;
  }
}
```

下面我们画一个圆形，并运行相同的动画

```javascript
@fadesUp
class Circle extends React.Component {
  render () {
    return <div className="circle"/>;
  }
}
```

够简单吧？


### 传递选项 ###


假设动画默认0.3秒，但是正方形的时间为0.8秒。
这么干：

```javascript
@fadesUp({duration: 0.8})
class Box extends React.Component {
  render () {
    return <div className="box"/>;
  }
}

@fadesUp
class Circle extends React.Component {
  render () {
    return <div className="circle"/>;
  }
}
```

必须修改之前的`fadesUp`来接收可选的`选项options`，但由于装饰器的工作方式，它不像添加可选的第二个参数那么简单。

下面显示如何修改`fadesUp` HOC :

```
function makeFadesUp(Component, options = { duration: 0.3 }) {
  return class FadesUp extends React.Component {
    componentWillEnter (callback) {
      const el = findDOMNode(this);
      TweenMax.fromTo(el, options.duration, {y: 100, opacity: 0}, {y: 0, opacity: 1, onComplete: callback});
    }

    componentWillLeave (callback) {
      const el = findDOMNode(this);
      TweenMax.fromTo(el, options.duration, {y: 0, opacity: 1}, {y: -100, opacity: 0, onComplete: callback});
    }

    render () {
      return <Component ref="child" {...this.props} />;
    }
  }
}

function fadesUp (Component) {
  return typeof arguments[0] === 'function'
    ? makeFadesUp(arguments[0])
    : Component => makeFadesUp(Component, arguments[0]);
}
```

`fadesUp`现在检查收到的第一个参数的类型是否是一个`function`，当没有选项被传递时，我们假设我们收到了一个React类（es6类有typeof ===函数），所以我们
马上加强吧。 
如果它没有收到函数，它会认为它收到`options`，并返回一个部分应用的函数，当下一次被调用时将会增强传递的组件以使用之前接收到的`options`来调用它。

下面是HOC`fadesUp`不用ES7装饰器的写法，可能更容易理解:

```
const Box = fadesUp({duration: 0.8})(class extends React.Component {
  render () {
    return <div className="box"/>;
  }
});

const Circle = fadesUp(class extends React.Component {
  render () {
    return <div className="circle"/>;
  }
});
```


[在线demo，在线调试](https://codepen.io/cheapsteak/pen/RaGKOZ?editors=0010)。


接下来的部分将集成反应路由器和协调嵌套动画。

关于高阶元件的更多文章:
[构建React程序:高阶元件](http://jamesknelson.com/structuring-react-applications-higher-order-components/)
构建React应用程序:高阶组件

在Twitter上关注Chang Wang


### 留言板 ###
#### 1 ####
Eddy Hernandez  
埃迪·埃尔南德斯  
Mar 28, 2016  
2016年3月28日  
这真的帮助我理解了TransitionGroup。 
谢谢！
 
#### 2 ####
Ben Bissonnette   
Apr 22  
4月22日
You ever get this working with React Router v4 ?
你开始写下一篇文章React路由v4吗？ 

Chang Wang    
Apr 22    
4月22日   
还没有做，确定他们的API稳定了？ 


unlitechc  
Feb 20  
2月20日
你以前的帖子帮我，拉刷新和加载更多列表（a pull to refresh  &  load-more list）。  
谢谢。

我读了几遍，试着做一个简单的装饰器，但我发现当代码

export function fadeInOut(Component){} 

and 

Read more
阅读更多

Chang Wang  
Feb 21  
2月21日  
Hi, any luck trying to fork the pen in the example?
嗨，试图在示例中分叉笔的运气？

http : //codepen.io/cheapsteak/pen/aNmpaz  


tadeouy  
Aug 18, 2016  
2016年8月18日  
感谢写了这篇文章，其内容非常清晰，让我深入了解GSAP在我的程序中的整合方式。

现在当我尝试用react-router嵌套路由时，发现很难和TransitionGroup整合在一起。 
每次路由变化的时候，都会重新渲染容器路由。   
你知道它可能吗？

Read more
阅读更多

Chang Wang  
Aug 19, 2016  
2016年8月19日   
嗨tadeouy，谢谢你的鼓励！    
我仍在研究路由集成的文章（老实说我一直在拖延），但我想我可以帮你解决这个问题先：）

确保你使用的`key`反映了你的程序的层次结构。





#### 参考 ####

* [React高阶组件（译） - 腾讯Web前端 IMWeb 团队社区 - blog - 团队博客](http://imweb.io/topic/5907038a2739bbed32f60dad)
* [React文档阅读--ps,DOM,js,HTML,组件,我们,props,使用,可以](http://www.bijishequ.com/detail/262287?p=70)
* [React - 高阶组件（Higher-Order Components） · Issue #52 · tcatche/tcatche.github.io · GitHub](https://github.com/tcatche/tcatche.github.io/issues/52)