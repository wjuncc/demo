---
layout: post
title:  "复用React动画（译）"
date:   2017-12-11 03:45:26 +0800
categories:  
tags: 
    - react
    - 笔记

---

Mar 14, 2016

**关于标题**  
原名，[Reusing ReactTransitionGroup animations with Higher-order Components](https://medium.com/appifycanada/reusing-reacttransitiongroup-animations-with-higher-order-components-1e7043451f91)  
《使用高阶组件重用ReactTransitionGroup动画》，好拗口。    
《使用HOC重用RTG动画》，太晦涩。  
《复用React动画》。 

## **小结**  ##

* 在线Demo的代码，和教程的代码，不一样。
* 教程用了es7的写法，而现在普遍是es6
* 在github搜索了一下，发现HOC+TweenMax的少之又少，看来实战中，不这么用。  
在github搜索 TweenMax componentWillEnter findDOMNode ,  
能得到很多线索。  
* 高阶组件，HOC，套，是一个东西，很重要。  
HOC有2种写法，`PP`和`II`。本教程用的是`PP`，也就是属性代理。   
但是，本教程的PP，和[`高阶教程`](https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e)的PP，写法完全不同。  
主要卡在render函数，按照[`高阶教程`](https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e)的写法，渲染的时候，添加前置声明，可以将内组件的引用传给HOC的函数。  
但是，生死钩比较特殊，它本身就带一个callback参数，这个时候，是添加新的参数？这不会破坏结构吗？就不知道该怎么写了。   
而且，退一步讲，**即便是把内组件的引用顺利的传给生死钩，传过来的引用也是虚拟DOM，不是原始DOM。** 这有什么用？ 而TweenMax要求操作的是原始DOM。    
所以，下面的写法，还是用本篇叫教程的写法来做的。 

## 笔记 ##
运行结果：  
![3](https://i.imgur.com/tuKRKyu.gif) 

文件： E:\n\learn\react\101\Ch04\proj3  

运行： 
	
	cd E:\n\learn\react\101\Ch04\proj3
	npm start

index.html

```html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="src/TweenMax.js"></script>
    <style>
        .box{
            width:200px;
            height:200px;
            background-color: brown;
        }
        .circle { 
            width:200px;
            height:200px;
            background-color: darkorange;
            border-radius: 100%;
        }
    </style>
</head>
<body>
    <div id="container"></div>
</body>
</html>
```


index.js
```javascript
import React from 'react';
import {findDOMNode} from 'react-dom';
import { render } from 'react-dom';
import TransitionGroup from 'react-addons-transition-group';


function makeFadesUp(Component, options = { duration: 0.3 }) {
  return class FadesUp extends React.Component {
    componentWillEnter (callback) {
        const el = findDOMNode(this);
        TweenMax.fromTo(el, options.duration, {y: 100, opacity: 0}, {y: 0, opacity: 1, onComplete: callback});
    }
    componentWillLeave (callback) {
        const el = findDOMNode(this);
        TweenMax.fromTo(el, options.duration, {y: 0, opacity: 1}, {y: -100, opacity: 0, onComplete: callback});
    }
    render () {
        return <Component ref="child" {...this.props} />;
    }
  }
}

function fadesUp (Component) {
  return typeof arguments[0] === "function"
    ? makeFadesUp(arguments[0])
    : Component => makeFadesUp(Component, arguments[0]);
}

const Box = fadesUp({duration: 0.8})(
    class extends React.Component {
    render () {
        return <div className="box"/>;
    }
});

const Circle = fadesUp(
    class extends React.Component {
    render () {
        return <div className="circle"/>;
    }
});

class Page extends React.Component {
    constructor() {
        super();
        this.toggleBox = this.toggleBox.bind(this);
		this.state = {
			shouldShowBox: true,
            shouldShowCircle: false
		};
    };

    toggleBox(){
        this.setState({
            shouldShowBox: !this.state.shouldShowBox,
            shouldShowCircle: !this.state.shouldShowCircle
        });
    };

    render () {
        return <div className="page">
            <TransitionGroup>
                { this.state.shouldShowBox && <Box/>}
                { this.state.shouldShowCircle && <Circle/>}
            </TransitionGroup>

			<button
				className="toggle-btn"
				onClick={this.toggleBox}
			>
				toggle
			</button>
		</div>;
    }
}

render(<Page/>, document.querySelector('#container'));
```
 


## 原文 ##
**前情回顾**  
上一讲，以一个正方形为例，讲了动画的写法。

上一讲讲过，为了让过渡组内的组件更灵活——不同阶段运行不同动画，不在过渡组定义动画，而是在过渡组的子组件定义动画，具体是指：添加生死钩-进入（enter），删除生死钩-离开（leave）。


但是，有的时候，多个组件要使用相同动画，又不希望下作的复制代码。   
可以通过使用高阶组件（Higher-order Components ——HOC）来实现。 
（如果不熟悉HOC，看[这里](http://efe.baidu.com/blog/mixins-are-dead-long-live-the-composition/)，[英语原文](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750)）


### 提取动画 ###

接着上一讲的Box组件实例继续。

```javascript
class Box extends React.Component {
  componentWillEnter (callback) {
    const el = findDOMNode(this);
    TweenMax.fromTo(el, 0.3, {y: 100, opacity: 0}, {y: 0, opacity: 1, onComplete: callback});
  }

  componentWillLeave (callback) {
    const el = findDOMNode(this);
    TweenMax.fromTo(el, 0.3, {y: 0, opacity: 1}, {y: -100, opacity: 0, onComplete: callback});
  }

  render () {
    return <div className="box"/>;
  }
}
```

可以将动画部分提取到名为“`fadesUp`”的高阶组件。

```javascript
function fadesUp (Component) {
  return class FadesUp extends React.Component {
    componentWillEnter (callback) {
      const el = findDOMNode(this);
      TweenMax.fromTo(el, 0.3, {y: 100, opacity: 0}, {y: 0, opacity: 1, onComplete: callback});
    }

    componentWillLeave (callback) {
      const el = findDOMNode(this);
      TweenMax.fromTo(el, 0.3, {y: 0, opacity: 1}, {y: -100, opacity: 0, onComplete: callback});
    }

    render () {
      return <Component ref="child" {...this.props} />;
    }
  }
}
```


想让组件运行动画？ 只要把组件传递给`fadesUp`，就行了。 

下面是正方形

```javascript
const Box = fadesUp(class extends React.Component {
  render () {
    return <div className="box"/>;
  }
});
```

或者，如果启用了装饰器（参考[通过Babel 6使用ES7装饰器](http://technologyadvice.github.io/es7-decorators-babel6/)）

```javascript
@fadesUp
class Box extends React.Component {
  render () {
    return <div className="box"/>;
  }
}
```

下面我们画一个圆形，并运行相同的动画

```javascript
@fadesUp
class Circle extends React.Component {
  render () {
    return <div className="circle"/>;
  }
}
```

够简单吧？


### 传递选项 ###


假设动画默认0.3秒，但是正方形的时间为0.8秒。
这么干：

```javascript
@fadesUp({duration: 0.8})
class Box extends React.Component {
  render () {
    return <div className="box"/>;
  }
}

@fadesUp
class Circle extends React.Component {
  render () {
    return <div className="circle"/>;
  }
}
```

必须修改之前的`fadesUp`来接收可选的`选项options`，但由于装饰器的工作方式，它不像添加可选的第二个参数那么简单。

下面显示如何修改`fadesUp` HOC :

```
function makeFadesUp(Component, options = { duration: 0.3 }) {
  return class FadesUp extends React.Component {
    componentWillEnter (callback) {
      const el = findDOMNode(this);
      TweenMax.fromTo(el, options.duration, {y: 100, opacity: 0}, {y: 0, opacity: 1, onComplete: callback});
    }

    componentWillLeave (callback) {
      const el = findDOMNode(this);
      TweenMax.fromTo(el, options.duration, {y: 0, opacity: 1}, {y: -100, opacity: 0, onComplete: callback});
    }

    render () {
      return <Component ref="child" {...this.props} />;
    }
  }
}

function fadesUp (Component) {
  return typeof arguments[0] === 'function'
    ? makeFadesUp(arguments[0])
    : Component => makeFadesUp(Component, arguments[0]);
}
```

`fadesUp`现在检查收到的第一个参数的类型是否是一个`function`，当没有选项被传递时，我们假设我们收到了一个React类（es6类有typeof ===函数），所以我们
马上加强吧。 
如果它没有收到函数，它会认为它收到`options`，并返回一个部分应用的函数，当下一次被调用时将会增强传递的组件以使用之前接收到的`options`来调用它。

下面是HOC`fadesUp`不用ES7装饰器的写法，可能更容易理解:

```
const Box = fadesUp({duration: 0.8})(class extends React.Component {
  render () {
    return <div className="box"/>;
  }
});

const Circle = fadesUp(class extends React.Component {
  render () {
    return <div className="circle"/>;
  }
});
```


[在线demo，在线调试](https://codepen.io/cheapsteak/pen/RaGKOZ?editors=0010)。


接下来的部分将集成反应路由器和协调嵌套动画。

关于高阶元件的更多文章:
[构建React程序:高阶元件](http://jamesknelson.com/structuring-react-applications-higher-order-components/)
构建React应用程序:高阶组件

在Twitter上关注Chang Wang


### 留言板 ###
#### 1 ####
Eddy Hernandez  
埃迪·埃尔南德斯  
Mar 28, 2016  
2016年3月28日  
这真的帮助我理解了TransitionGroup。 
谢谢！
 
#### 2 ####
Ben Bissonnette   
Apr 22  
4月22日
You ever get this working with React Router v4 ?
你开始写下一篇文章React路由v4吗？ 

Chang Wang    
Apr 22    
4月22日   
还没有做，确定他们的API稳定了？ 


unlitechc  
Feb 20  
2月20日
Your previous post help me build a pull to refresh  &  load-more list.
你以前的帖子帮我，建立拉刷新和加载更多列表。
Thanks.
谢谢。

Ive read your post several times and try to make a simple decorator, but I find when I code
我几次读你的帖子，并尝试做一个简单的装饰，但我发现当我编码

export function fadeInOut(Component){}
导出函数fadeInOut（Component）{}

and
和

Read more
阅读更多

1 response
1回应
Go to the profile of Chang Wang
转到长王的档案
Chang Wang
常王
Feb 21
2月21日
Hi, any luck trying to fork the pen in the example?
嗨，试图在示例中分叉笔的运气？

http : //codepen.io/cheapsteak/pen/aNmpaz
http _... //codepen.io/cheapsteak/pen/aNmpaz



Conversation with Chang Wang.
与张望的对话。
Go to the profile of tadeouy
转到tadeouy的个人资料
tadeouy
tadeouy
Aug 18, 2016
2016年8月18日
Thank you for this article, its very clear and gave me insight about the way of integrating GSAP in my react app.
感谢您阅读这篇文章，其内容非常清晰，让我深入了解GSAP在我的应用程序中的整合方式。

Now Im having a hard time to make TransitionGroup work with react-router with a few nested routes.
现在我很难使TransitionGroup与反应路由器与几个嵌套的路线工作。
Im getting the container route being re-rendered on each route change.
我得到的容器路线重新呈现每个路线的变化。
Do you know if its possible?
你知道它可能吗？

Read more
阅读更多

1 response
1回应
Go to the profile of Chang Wang
转到长王的档案
Chang Wang
常王
Aug 19, 2016
2016年8月19日
Hi tadeouy, thank you for the kind words!
嗨tadeouy，谢谢你的客气话！

Im still working on the the article on router integration (to be honest Ive been procrastinating a bit), but I think I can help you with that problem  : )
我仍然在研究有关路由器集成的文章（老实说我一直在拖延一下），但我想我可以帮你解决这个问题_...）

Make sure that the `key` youre using reflects the hierarchy of your app.
确保你使用的``键反映了你的应用程序的层次结构。





#### 参考 ####

* [React高阶组件（译） - 腾讯Web前端 IMWeb 团队社区 - blog - 团队博客](http://imweb.io/topic/5907038a2739bbed32f60dad)
* [React文档阅读--ps,DOM,js,HTML,组件,我们,props,使用,可以](http://www.bijishequ.com/detail/262287?p=70)
* [React - 高阶组件（Higher-Order Components） · Issue #52 · tcatche/tcatche.github.io · GitHub](https://github.com/tcatche/tcatche.github.io/issues/52)